static const char *RcsId     = "$Header$";
static const char *TagName   = "$Name$";
static const char *HttpServer= "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        AdlinkAIOClass.cpp
//
// description : C++ source for the AdlinkAIOClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the AdlinkAIO once per process.
//
// project :     TANGO Device Server
//
// $Author: rsune $
//
// $Revision: 8649 $
//
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================


#include <tango.h>

#include <AdlinkAIO.h>
#include <AdlinkAIOClass.h>
#include <memory>

//+----------------------------------------------------------------------------
/**
 *	Create AdlinkAIOClass singleton and return it in a C function for Python usage
 */
//+----------------------------------------------------------------------------
extern "C" {
#ifdef WIN32

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_AdlinkAIO_class(const char *name) {
		return AdlinkAIO_ns::AdlinkAIOClass::init(name);
	}
}


namespace AdlinkAIO_ns
{
//+----------------------------------------------------------------------------
//
// method : 		StartCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartCmd::execute(): arrived" << endl;

	((static_cast<AdlinkAIO *>(device))->start());
	return new CORBA::Any();
}



//+----------------------------------------------------------------------------
//
// method : 		StopClass::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StopClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StopClass::execute(): arrived" << endl;

	((static_cast<AdlinkAIO *>(device))->stop());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		CalibrationAutoCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *CalibrationAutoCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "CalibrationAutoCmd::execute(): arrived" << endl;

	((static_cast<AdlinkAIO *>(device))->calibration_auto());
	return new CORBA::Any();
}

CORBA::Any *CalibrationSaveCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "CalibrationSaveCmd::execute(): arrived" << endl;

	Tango::DevULong bank;
	extract(in_any, bank);
	((static_cast<AdlinkAIO *>(device))->calibration_save(bank));
	return new CORBA::Any();
}

CORBA::Any *CalibrationLoadCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "CalibrationLoadCmd::execute(): arrived" << endl;

	Tango::DevULong bank;
	extract(in_any, bank);
	((static_cast<AdlinkAIO *>(device))->calibration_load(bank));
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		ImportFileCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ImportFileCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ImportFileCmd::execute(): arrived" << endl;

	return insert((static_cast<AdlinkAIO *>(device))->import_file());
}

//+----------------------------------------------------------------------------
//
// method : 		ExportFileCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ExportFileCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ExportFileCmd::execute(): arrived" << endl;

	return insert((static_cast<AdlinkAIO *>(device))->export_file());
}

//+----------------------------------------------------------------------------
//
// method : 		ClearBufferCmd::execute()
//
// description : 	****************************
//
// in : - void
//
// returns : void
//
//-----------------------------------------------------------------------------
CORBA::Any *ClearBufferCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ClearBufferCmd::execute(): arrived" << endl;

	((static_cast<AdlinkAIO *>(device))->clear_buffer());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		GetDataCmd::execute()
//
// description : 	****************************
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *GetDataCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "GetDataCmd::execute(): arrived" << endl;
	const Tango::DevVarLongStringArray *argin;
	extract(in_any, argin);

	return insert((static_cast<AdlinkAIO *>(device))-> get_data(argin));
}
//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
AdlinkAIOClass *AdlinkAIOClass::_instanceAI = NULL;
AdlinkAIOClass *AdlinkAIOClass::_instanceAO = NULL;

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::AdlinkAIOClass(string &s)
// 
// description : 	constructor for the AdlinkAIOClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
AdlinkAIOClass::AdlinkAIOClass(string &s):DeviceClass(s)
{
	cout2 << "Entering AdlinkAIOClass constructor" << endl;
	if (s == std::string("AdlinkAI")) {
		this->m_isInput = true;
	} else {
		this->m_isInput = false;
	}

	set_default_property();
	get_class_property();
	write_class_property();
	
	cout2 << "Leaving AdlinkAIOClass constructor" << endl;


	// All signals used by adlink (see also destructor)
	// This way we ask Tango to leave them go to the program
	// but do not handle. By default it tries to handle all signals
	// by itself.
	for (int signal = 57; signal <= 62; ++signal)
		this->register_signal(signal, true);

}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::~AdlinkAIOClass()
// 
// description : 	destructor for the AdlinkAIOClass
//
//-----------------------------------------------------------------------------
AdlinkAIOClass::~AdlinkAIOClass()
{
	// All signals used by Adlink (see also constructor)
	for (int signal = 57; signal <= 62; ++signal)
			this->unregister_signal(signal);

	if (this->m_isInput)
		_instanceAI = NULL;
	else
		_instanceAO = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::instance
// 
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
AdlinkAIOClass *AdlinkAIOClass::init(const char *_name)
{
	std::string name(_name);
	bool isInput = (name == "AdlinkAI");

	if (isInput) {
		if (_instanceAI)
			return _instanceAI;
		_instanceAI = new AdlinkAIOClass(name);
		return _instanceAI;
	} else {
		if (_instanceAO)
			return _instanceAO;
		_instanceAO = new AdlinkAIOClass(name);
		return _instanceAO;
	}
}

AdlinkAIOClass *AdlinkAIOClass::instance()
{
// 	if (_instance == NULL)
// 	{
// 		cerr << "Class is not initialised !!" << endl;
// 		exit(-1);
// 	}
// 	return _instance;
	// We are using this C++ class to define 2 Tango classes...
	// Then this call does not know which one to return, so it has no sense.
	cerr << "AdlinkAIOClass::instance() should not be used" << endl;
	exit(-1);
	return 0;
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void AdlinkAIOClass::command_factory()
{
	command_list.push_back(new StartCmd("Start",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StopClass("Stop",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new CalibrationAutoCmd("CalibrationAuto",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"Runs the auto calibration function of the board(if available). ACHTUNG: It needs exclusive access to the board, so it will kill any other device running in this device server. Also, remember to disconnect all the cables before running it!! See also CalibrationSave.",
		Tango::EXPERT));
	command_list.push_back(new CalibrationSaveCmd("CalibrationSave",
		Tango::DEV_ULONG, Tango::DEV_VOID,
		"EEPROM storage bank number, 0 to 3.",
		"Saves the current calibration settings into the EEPROM. See the board documentation. You can use CalibrationAuto previously to set these settings and CalibrationLoad to restore from the EEPROM.",
		Tango::EXPERT));
	command_list.push_back(new CalibrationLoadCmd("CalibrationLoad",
		Tango::DEV_ULONG, Tango::DEV_VOID,
		"EEPROM storage bank number, 0 to 3.",
		"Restore the calibration settings saved with CalibrationSave.",
		Tango::EXPERT));
	command_list.push_back(new ImportFileCmd("ImportFile",
		Tango::DEV_VOID, Tango::DEV_BOOLEAN,
		"File Name",
		"Ok",
		Tango::OPERATOR));
	command_list.push_back(new ExportFileCmd("ExportFile",
		Tango::DEV_VOID, Tango::DEV_BOOLEAN,
		"File Name",
		"Ok",
		Tango::OPERATOR));

	command_list.push_back(new ClearBufferCmd("ClearBuffer",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"Clear statistics buffer",
		Tango::OPERATOR));

	command_list.push_back(new GetDataCmd("GetData",
				Tango::DEVVAR_LONGSTRINGARRAY, Tango::DEVVAR_DOUBLEARRAY,
				"Two arrays ('DevVarLongStringArray'). First array contains two indexes: start & end. Second array contains the attribute name e.g. C00_MeanValues",
				"Data (or part of data) specified by start and end indexes (both iclusive).",
				Tango::OPERATOR));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::get_class_property
// 
// description : 	Get the class property for specified name.
//
// in :		string	name : The property name
//
//+----------------------------------------------------------------------------
Tango::DbDatum AdlinkAIOClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::get_default_device_property()
// 
// description : 	Return the default value for device property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum AdlinkAIOClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::get_default_class_property()
// 
// description : 	Return the default value for class property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum AdlinkAIOClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::device_factory
// 
// description : 	Create the device object(s) and store them in the 
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void AdlinkAIOClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	// Erase all the dynamic attributes previously added to the class
	//-------------------------------------------------------------
	eraseDynamicAttributes(get_class_attr()->get_attr_list());
	//	Create all devices.(Automatic code generation)
	//-------------------------------------------------------------
	for (unsigned long i=0 ; i < devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		cout << "Creating Device name : " << (*devlist_ptr)[i].in() << endl;
						
		// Create devices and add it into the device list
		//----------------------------------------------------
		device_list.push_back(new AdlinkAIO(this, (*devlist_ptr)[i]));
	}

	// Add your own code here
	//-----------------------------------------
	addDynamicAttributes(devlist_ptr);

	// Export device to the outside world (Automatic code generation)
	//-------------------------------------------------------------
	for (unsigned long i=1 ; i <= devlist_ptr->length() ; i++)
	{
		//For exporting it must be done in INVERSE ORDER!!!!! (Because device_list is a LIFO)
		cout << "Exporting Device name : " << (*devlist_ptr)[devlist_ptr->length()-i].in() << endl;
		// Check before if database used.
		//---------------------------------------------
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(device_list[device_list.size()-i]);
		else
			export_device(device_list[device_list.size()-i],(*devlist_ptr)[devlist_ptr->length()-i]);
	}
	//	End of Automatic code generation
	//-------------------------------------------------------------
}
//+----------------------------------------------------------------------------
//	Method: AdlinkAIOClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void AdlinkAIOClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	//	Attribute : SampleRate
	SampleRateAttrib	*sample_rate = new SampleRateAttrib();
	Tango::UserDefaultAttrProp	sample_rate_prop;
	sample_rate_prop.set_label("SampleRate");
	sample_rate_prop.set_description("The sampling frequency used by the device.\n");
	sample_rate_prop.set_format("%10d");
	sample_rate->set_default_properties(sample_rate_prop);
	sample_rate->set_memorized();
	sample_rate->set_memorized_init(true);
	att_list.push_back(sample_rate);

	//	Attribute : Delay
	DelayAttrib	*delay = new DelayAttrib();
	Tango::UserDefaultAttrProp	delay_prop;
	delay_prop.set_label("Delay");
	delay_prop.set_description("Delay in delay trigger mode.\n");
	delay_prop.set_format("%10d");
	delay->set_default_properties(delay_prop);
	delay->set_memorized();
	delay->set_memorized_init(true);
	att_list.push_back(delay);

	//	Attribute : DelaySource
	DelaySourceAttrib	*delay_source = new DelaySourceAttrib();
	Tango::UserDefaultAttrProp	delay_source_prop;
	delay_source_prop.set_label("Delay Source");
	delay_source_prop.set_description("In Delay trigger mode, the \'Delay\' attribute can have several meanings. That is, what is the delay counting? :\n\t0: The TimeBase, the internal clock of the card\n\t1: Samples, just as if the first \'Delay\' samples of the acquisition were ignored.\nThe availability of these options depend on the board type.");
	delay_source_prop.set_format("%10d");
	delay_source->set_default_properties(delay_source_prop);
	delay_source->set_memorized();
	delay_source->set_memorized_init(true);
	att_list.push_back(delay_source);

	//	Attribute : DelaySource
	DelayDataReadyAttrib	*delay_data_ready = new DelayDataReadyAttrib();
	Tango::UserDefaultAttrProp	delay_data_ready_prop;
	delay_data_ready_prop.set_label("Delay Data Ready");
	delay_data_ready_prop.set_description("Number of points between emitting DATA_READY events.");
	delay_data_ready_prop.set_format("%10d");
	delay_data_ready->set_default_properties(delay_data_ready_prop);
	delay_data_ready->set_memorized();
	delay_data_ready->set_memorized_init(true);
	att_list.push_back(delay_data_ready);

	//	Attribute : ChannelSamplesPerTrigger
	ChannelSamplesPerTriggerAttrib	*channel_buffer_size = new ChannelSamplesPerTriggerAttrib();
	Tango::UserDefaultAttrProp	channel_buffer_size_prop;
	channel_buffer_size_prop.set_label("ChannelSamplesPerTrigger");
	channel_buffer_size_prop.set_description("Size of the buffer used for each channel by this tango device. maxTotalBufferSize/numOfChannels");
	channel_buffer_size->set_default_properties(channel_buffer_size_prop);
	channel_buffer_size->set_memorized();
	channel_buffer_size->set_memorized_init(true);
	att_list.push_back(channel_buffer_size);

	//	Attribute : NumOfDisplayableTriggers
	if (this->m_isInput) {
		NumOfDisplayableTriggersAttrib	*num_of_displayable_triggers = new NumOfDisplayableTriggersAttrib();
		Tango::UserDefaultAttrProp	num_of_displayable_triggers_prop;
		num_of_displayable_triggers_prop.set_label("NumOfDisplayableTriggers");
		num_of_displayable_triggers_prop.set_description("The number of triggers that will be shown in CXX_ChannelValues. So, the maximum CXX_ChannelValues size is NumOfDisplayableTriggers*ChannelSamplesPerTrigger. -1 means NumOfDisplayableTriggers=NumOfTriggers");
		num_of_displayable_triggers->set_default_properties(num_of_displayable_triggers_prop);
		num_of_displayable_triggers->set_memorized();
		num_of_displayable_triggers->set_memorized_init(true);
		att_list.push_back(num_of_displayable_triggers);
	}

	//	Attribute : NumOfTriggers
	NumOfTriggersAttrib	*num_of_shots = new NumOfTriggersAttrib();
	Tango::UserDefaultAttrProp	num_of_shots_prop;
	num_of_shots_prop.set_label("NumOfTriggers");
	num_of_shots_prop.set_description("The number of times that the entire buffer will be processed. It can be acquired/generated only one time if the value is 1, only for 5 times. \n<br/>Its behavior will change depending of the selected TriggerMode.");
	num_of_shots->set_default_properties(num_of_shots_prop);
	num_of_shots->set_memorized();
	num_of_shots->set_memorized_init(true);
	att_list.push_back(num_of_shots);

	//	Attribute : MaxRefSource
	MaxRefSourceAttrib	*max_ref_source = new MaxRefSourceAttrib();
	Tango::UserDefaultAttrProp	max_ref_source_prop;
	max_ref_source_prop.set_label("MaxRefSource");
	max_ref_source_prop.set_description("Maximum reference source value (rel. to Units Prop.)\n");
	max_ref_source->set_default_properties(max_ref_source_prop);
	max_ref_source->set_memorized();
	max_ref_source->set_memorized_init(true);
	att_list.push_back(max_ref_source);

	//	Attribute : MinRefSource
	MinRefSourceAttrib	*min_ref_source = new MinRefSourceAttrib();
	Tango::UserDefaultAttrProp	min_ref_source_prop;
	min_ref_source_prop.set_description("Minimum reference source value (rel. to Units Prop.)\n<br/>The Bipolar Range, Internal Reference and Reference Source Value can be deprecated, so they are more specific than needed. I think that it\'s better to use two values and allow asymmetric reference settings by default.");
	min_ref_source->set_default_properties(min_ref_source_prop);
	min_ref_source->set_memorized();
	min_ref_source->set_memorized_init(true);
	att_list.push_back(min_ref_source);

	//	Attribute : TriggerHighLimit
	TriggerHighLimitAttrib	*trigger_high_limit = new TriggerHighLimitAttrib();
	Tango::UserDefaultAttrProp	trigger_high_limit_prop;
	trigger_high_limit_prop.set_description("See TriggerSources. It is only valid if TriggerSources is  ANA:avobe-high, ANA:inside-region, ANA:low-hysteresis or ANA:high-hysteresis");
	trigger_high_limit->set_default_properties(trigger_high_limit_prop);
	trigger_high_limit->set_memorized();
	trigger_high_limit->set_memorized_init(true);
	att_list.push_back(trigger_high_limit);

	//	Attribute : TriggerLowLimit
	TriggerLowLimitAttrib	*trigger_low_limit = new TriggerLowLimitAttrib();
	Tango::UserDefaultAttrProp	trigger_low_limit_prop;
	trigger_low_limit_prop.set_description("See TriggerSources. It is only valid if TriggerSources is ANA:below-low, ANA:inside-region, ANA:low-hysteresis or ANA:high-hysteresis");
	trigger_low_limit->set_default_properties(trigger_low_limit_prop);
	trigger_low_limit->set_memorized();
	trigger_low_limit->set_memorized_init(true);
	att_list.push_back(trigger_low_limit);
	
	//	Attribute : TriggerSources
	TriggerSourcesAttrib	*trigger_sources = new TriggerSourcesAttrib();
	Tango::UserDefaultAttrProp	trigger_sources_prop;
	trigger_sources_prop.set_description("An identifier to the available trigger signals used by the device, if empty defaults to internal or software triggering.\n<br/>Valid values are:<ul><li> <b>SOFT</b> Software trigger, start at the Start command itself.</li><li> <b>ExtD:+</b> External digital trigger, positive polarity.</li><li> <b>ExtD:-</b> for inverse polarity.</li><li> <b>SSI</b></li><li> <b>ANA:*option*</b> Configurable external analog trigger:<ul><li><b>ANA:below-low</b> for BelowLowLevel mode </li><li><b>ANA:avobe-high</b> for AvobeHighLevel mode</li><li><b>ANA:inside-region</b> </li><li><b>ANA:low-hysteresis</b> for LowHysteresis</li><li><b>ANA:high-hysteresis</b> for HighHysteresis</il></ul>The limits for the analog modes are set with the attributes TriggerLowLimit and TriggerHighLimit.</il></ul>");
	trigger_sources->set_default_properties(trigger_sources_prop);
	trigger_sources->set_memorized();
	trigger_sources->set_memorized_init(true);
	att_list.push_back(trigger_sources);

	//	Attribute : TriggerMode
	TriggerModeAttrib	*trigger_mode = new TriggerModeAttrib();
	Tango::UserDefaultAttrProp	trigger_mode_prop;
	trigger_mode_prop.set_description("<ul><li>0: POST</li><li>1: DELAY</li><li>2: PRE (AI only)</li><li>3: MIDL (AI only)</li></ul>");
	trigger_mode->set_default_properties(trigger_mode_prop);
	trigger_mode->set_memorized();
	trigger_mode->set_memorized_init(true);
	att_list.push_back(trigger_mode);
	
	//	Attribute : TriggerInfinite
	TriggerInfiniteAttrib	*trigger_infinite = new TriggerInfiniteAttrib();
	Tango::UserDefaultAttrProp	trigger_infinite_prop;
	trigger_infinite_prop.set_description("Perform the operation indefinitelly?\n\t0: No.\n\t1: Yes, once the first trigger arribes.\n\t2: Yes, then wait for the next trigger.");
	trigger_infinite->set_default_properties(trigger_infinite_prop);
	trigger_infinite->set_memorized();
	trigger_infinite->set_memorized_init(true);
	att_list.push_back(trigger_infinite);

	//	Attribute : BufferPeriod
	BufferPeriodAttrib	*buffer_period = new BufferPeriodAttrib();
	Tango::UserDefaultAttrProp	buffer_period_prop;
	buffer_period_prop.set_description("Just an Interface between BufferSize and its equivalent in time units (depending of SampleRate). BufferSize and BufferPeriod will be the same internal variable that could be readed/modified using different unit  (Samples or milliseconds)  from two different attributes. It will not get it\'s memorized value automatically when the device starts, as it would conflict with SampleRate. Use SampleRate instead.");
	buffer_period->set_default_properties(buffer_period_prop);
	buffer_period->set_memorized();
	buffer_period->set_memorized_init(false);
	att_list.push_back(buffer_period);

	//	Attribute : BufferedChannelsList
	BufferedChannelsListAttrib	*buffered_channels_list = new BufferedChannelsListAttrib();
	Tango::UserDefaultAttrProp	buffered_channels_list_prop;
	buffered_channels_list_prop.set_description("Array or Spectrum with the Identifiers of all channels actually used by this device that are sharing the internal Hardware Buffer (it won\'t be equal to the number of channels available). If it is not written it\'s understood that all the available channels are used.<br/>\nThe Size/Length of this Array/Vector provides us the total number of channels used (and the *Values/*DATA Attributes Dimensions). It would be something like: ['<i>ai2</i>','<i>ai3</i>','<i>ai5</i>'] , each of strings identifying the channels used in the same order.");
	buffered_channels_list->set_default_properties(buffered_channels_list_prop);
	att_list.push_back(buffered_channels_list);

	//	Attribute : RawDATA
	RawDATAAttrib	*raw_data = new RawDATAAttrib();
	Tango::UserDefaultAttrProp	raw_data_prop;
	raw_data_prop.set_description("Raw Binary values acquired directly from the DAQ conversion. Read/Write permissions will depend of the Analog Input/Output Property implementation. \n<br/>The Dimensions of this attribute will be determined by ChannelSamplesPerTrigger and the BufferedChannelsList Size, so it could be resized <i>on the fly</i>.");
	raw_data->set_default_properties(raw_data_prop);
	att_list.push_back(raw_data);

	//	Attribute : DoubleDATA
	DoubleDATAAttrib	*double_data = new DoubleDATAAttrib();
	Tango::UserDefaultAttrProp	double_data_prop;
	double_data_prop.set_description("Just an interface to convert each value of the RawDATA image to its equivalent normalized inside the Reference Source Range specified (MaxSourceRef and MinSourceRef Attributes).");
	double_data->set_default_properties(double_data_prop);
	att_list.push_back(double_data);

	//	Attribute : FileName
	FileNameAttrib	*file_name = new FileNameAttrib();
	file_name->set_memorized();
	file_name->set_memorized_init(true);
	att_list.push_back(file_name);

// 	//	Attribute : ScalarValue
// 	ScalarValueAttrib	*scalar_value = new ScalarValueAttrib();
// 	scalar_value->set_memorized();
// 	scalar_value->set_memorized_init(false);
// 	att_list.push_back(scalar_value);
// 
// 	//	Attribute : ChannelSpectrum
// 	ChannelSpectrumAttrib	*channel_spectrum = new ChannelSpectrumAttrib();
// 	att_list.push_back(channel_spectrum);

	//	Attribute : LastValues
	LastValuesAttrib	*last_values = new LastValuesAttrib();
	Tango::UserDefaultAttrProp	last_values_prop;
	last_values_prop.set_description("Shows the last value of all channels.");
	last_values->set_default_properties(last_values_prop);
	att_list.push_back(last_values);

	//	End of Automatic code generation
	//-------------------------------------------------------------
	vector<Tango::Attr *>::iterator i;
	if (!default_Attribute_list.size()) {
		printf("Saving default attribute list (not-Dynamic Attributes) ...\n");
		for (i=att_list.begin(); i != att_list.end(); ++i) {
			default_Attribute_list.push_back((*i)->get_name());
			printf("\tAdded %s\n",default_Attribute_list[default_Attribute_list.size()-1].c_str());
		}
	}
	eraseDynamicAttributes(att_list);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::get_class_property()
// 
// description : 	Read the class properties from database.
//
//-----------------------------------------------------------------------------
void AdlinkAIOClass::get_class_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read class properties from database.(Automatic code generation)
	//------------------------------------------------------------------

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;


	//	End of Automatic code generation
	//------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 	AdlinkAIOClass::set_default_property
// 
// description: Set default property (class and device) for wizard.
//              For each property, add to wizard property name and description
//              If default value has been set, add it to wizard property and
//              store it in a DbDatum.
//
//-----------------------------------------------------------------------------
void AdlinkAIOClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;

	vector<string>	vect_data;
	//	Set Default Class Properties
	//	Set Default Device Properties
	prop_name = "BoardId";
	prop_desc = "It must be an unique identifier for each card on the PC/Rack where it is installed. It is the Board Number in the Rack. So if there are two cards of the same BoardType in the rack, the first will have BoardId=0 and the other BoardId=1.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "BoardType";
	prop_desc = "Product descriptor that allow us to identify the card type. Supported values are: DAQ_2205, DAQ_2213, DAQ_2502, DAQ_2005, DAQ_2010, PCI_6202, PCI_6208V, PCI_6208A, PCI_9116.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "OnBoardBuffer";
	prop_desc = "How much memory the driver can use (at most AI_PAGE or AO_PAGE *4096*2 ). A device with NumOfChannels=1 will never request buffers longer than this to the driver, so if ChannelSamplesPerTrigger is bigger, it will be read step by step, in chunks of OnBoardBuffer/NumOfChannels size each. In practise, board buffer is shared by all the channels so if you want the driver to acquire for you a buffer of X samples, you need: ChannelSamplesPerTrigger=X and OnBoardBuffer=X*NumOfChannels. If you don't know where to put AI_PAGE and AO_PAGE, check the driver configuration.\n";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "MaxSampleRate";
	prop_desc = "Maximum Sample Rate (per Channel) that is capable the DAQ Card.\n-> The SampleRate.MaxValue Attribute Property will be fixed each time this Property is modified.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "MaxSourceRange";
	prop_desc = "Maximum Source Range allowed (Bipolar), it is understood as +/-MaxSourceRange.\n-> The Attributes MaxSourceRef and MinSourceRef will adapt its MaxValue and MinValue Properties to the value stored in this Property.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "DynamicRange";
	prop_desc = "Number of Bits of the DAQ Converter.\n-> It allows to convert from RawDATA (binary obtained from the Analog to Digital converter) to DoubleDATA (float point values normalized in the SourceRange).";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Units";
	prop_desc = "Units concerning to the data measured/generated.\n-> This property will modify the units for all related Attributes.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "NumOfChannels";
	prop_desc = "Total number of channels available in the DAQ card. This Property refers only to the Physical Channels of the same type of the Abstract Class (e.g. in an Analog Input Device it will refer only to the Analog Input Channels).\n-> It determines the maximum size of the Attribute BufferedChannels List and fixes the Attribute default value.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "ReferenceGround";
	prop_desc = "A/D input channels reference Ground Selection (only available for DAQ-2204/2205/2206/2208/2213/2214):\n  - DAQ-2010, DAQ-2005, DAQ-2006, DAQ-2501, DAQ-2502: 0\n   - DAQ-2204, DAQ-2205, DAQ-2206, DAQ-2208, DAQ-2213, DAQ-2214:\n   AI_RSE : Referenced single ended mode ( 64chs common to ground system on board) (default value)\n   AI_DIFF : Differential mode\n   AI_NRSE : Non-referenced single ended mode ( 64chs common to AISENSE pin )";
	prop_def  = "AI_RSE";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "AutoStart";
	prop_desc = "If set to true, device will be automatically started on init.";
	prop_def  = "0";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "UseCallbackSignals";
	prop_desc = "In this conditions are given:\n\t- It is set to true.\n\t- We are in a mode that can make use of callback signals.\n\t- The physical board supports signals for this mode.\nThen callback signals will be used, instead of a polling thread. \nDefault value is true. Analog Input only.";
	prop_def  = "1";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "UseSharedBuffer";
	prop_desc = "If it is true, it will always copy the contents of the acquisitions from driver memory to Tango. If it is set to false, in some cases (It's not always possible!) the data will be copied to tango space ONLY when reading of an attribute is requested.\nYou can disable \"UseSharedBuffer\" if you don't plan to access data while acquiring it, but after an external trigger, and you want very high acquisition speed.\nDefault value is true. Analog Input only.";
	prop_def  = "1";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableChannelValueEvents";
	prop_desc = "In Analog Input, if the value of an attribute changes the attribute will automatically push a change event. This applies only to CXX_ChannelValues attributes.\nIf event rate is high it is not desirable to enable this as it can cause serious issues.\nDefaults to false.";
	prop_def  = "0";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "EnableLastValueEvents";
	prop_desc = "In Analog Input, if the value of an attribute changes the attribute will automatically push a change event. This applies only to LastValues and CXX_LastValue attributes.\nIf event rate is high it is not desirable to enable this as it can cause serious issues.\nDefaults to false.";
	prop_def  = "0";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "StatsSettings";
	prop_desc = "Statistical operations to be performed. This means new"
		"attributes will be created. As an example, it will create\n"
		"all the available statistical attributes:\n"
		"<pre>\n"
		"  last_mean event\n"
		"  last_std_dev event\n"
		"  last_quadratic_mean event\n"
		"  buf_mean\n"
		"  buf_std_dev\n"
		"  buf_quadratic_mean\n"
		"  buf_mean_data_ready"
		"</pre>\n"
		"<i><b>last_</b>mean</i> means you want a new scalar attribute CXX_MeanLast\n"
		"with the value of the last buffer mean.<br/>\n"
		"<i><b>buf_</b>mean</i> means you want a new spectrum attribute CXX_MeanValues\n"
		"with the means of the last NumOfTriggers buffers.<br/>\n"
		"<i><b>event</b></i> after another token means that the previous attribute\n "
		"(ex CXX_MeanLast or CXX_MeanValues) will automatically push change events\n"
		"when new data is available.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		vect_data.clear();
		vect_data.push_back(prop_def);
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIOClass::write_class_property
// 
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void AdlinkAIOClass::write_class_property()
{
	//	First time, check if database used
	//--------------------------------------------
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Adlink Analog Input Output Device Server");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("Tango Device Server for Analog Input/Outputs, using Adlink devices and");
	str_desc.push_back("implementing the AnalogDAQ AbstractClass. <ul>");
	str_desc.push_back("<li> The start() and stop() commands will manage the process of acquisition");
	str_desc.push_back("<li> The Device Server manages both Analog Inputs and Outputs using an IsInput boolean property.");
	str_desc.push_back("<li> AdlinkAIO [DS] is an interface between Tango and the AdlinkDevice [HW] c++ object.");
	str_desc.push_back("<li> The values set for properties and some attributes are used to configure the hardware device.");
	str_desc.push_back("<li> rawData is the binary image (2D array) shared by [DS] and [HW] to move information between attributes and acquisition.");
	str_desc.push_back("<li> Each physical channel is stored in a different line of the rawData array.");
	str_desc.push_back("<li> Data attributes are dynamic, the property NumOfChannels determine the number of attributes to be created.");
	str_desc.push_back("<li> DevDouble Cxx_ChannelValues is a Read/Write Spectrum for each channel, uses read/write_ChannelSpectrum()");
	str_desc.push_back("<li> DevDouble Cxx_LastValue is a Read/Write Scalar for each channel, uses read/write_ScalarValue(), when reading gives the last value of the channel spectrum, when writing it overwrites all the values of the spectrum.");
	str_desc.push_back("<li> RawData and DoubleData attributes allow to read the full buffer image using binary or double formats.");
	str_desc.push_back("<li> Conversion between binary and voltage is HW dependant and done in the AdlinkDevice c++ object.");
	str_desc.push_back("</ul><br><br>");
	str_desc.push_back("Device States Description:");
	str_desc.push_back("<ul>");
	str_desc.push_back("Tango::STANDBY :  After Initialization or an stop() command received; this State allows the modification of all the attributes.<br>");
	str_desc.push_back("Tango::RUNNING :  A command start() received, The Device is processing data.<br>");
	str_desc.push_back("Tango::ON :       The device has finished the data acquisition/generation and is ready for a new start().<br>");
	str_desc.push_back("Tango::FAULT :    An Exception from Hardware or Driver has been received. The Status command will give more information about the Error.<br>");
	str_desc.push_back("Tango::UNKNOWN :  The Hardware has not been initialized");
	str_desc.push_back("</ul>");
	description << str_desc;
	data.push_back(description);
		
	//	put cvs location
	string	rcsId(RcsId);
	string	filename(classname);
	start = rcsId.find("/");
	if (start!=string::npos)
	{
		filename += "Class.cpp";
		end   = rcsId.find(filename);
		if (end>start)
		{
			string	strloc = rcsId.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	//	Get CVS tag revision
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("AnalogDAQ");
	inheritance.push_back("Device_4Impl");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	//--------------------------------------------
	get_db_class()->put_property(data);
}


///////////////////////////////////////////////////////////////////////////////
// Dynamic attributes...
///////////////////////////////////////////////////////////////////////////////

/// Function that diferentiates dynamic attributes from static ones
bool AdlinkAIOClass::isDynamicAttribute(string attrName)
{
		bool isIn=false;
		for (int j=0; j<default_Attribute_list.size(); j++) {
			if (attrName==default_Attribute_list[j]) {
				isIn=true; j=default_Attribute_list.size();
				}
			}
		if(	(attrName == "SpectrumAttribute" ||
			attrName == "ScalarAttribute" ||
			attrName == "ImageAttribute" ||
			!isIn) &&
			(attrName!="State" &&
			attrName!="Status"))
			return true;
		else return false;
}
/// Function that removes dynamic attributes from the class attributes list
void AdlinkAIOClass::eraseDynamicAttributes(vector<Tango::Attr *> &att_list)
{
	/// Erasing undesired attributes
	vector<Tango::Attr *>::iterator a;
	for(a=att_list.begin(); a != att_list.end(); ++a)
	{
		if(isDynamicAttribute((*a)->get_name()))
		{
			cout << "Erasing attribute "<<(*a)->get_name()<<endl;
			delete (*a);
			att_list.erase(a);
			--a;
		} //else cout << "Standing attribute "<<(*i)->get_name()<<endl;
	}
}

static void addInputChannelDynamicAttributes(AdlinkAIO *myds, int chanNumber)
{
	char attr_name[50];
	char strtmp[200];
	
	const long data_type = Tango::DEV_DOUBLE;
	const Tango::AttrWriteType w_type = Tango::READ;
	
	cout << "Creating Input Channel " << chanNumber << endl;

	// -- Create scalar attribute
	{
		sprintf(attr_name, "C%02d_LastValue", chanNumber);
		std::auto_ptr<Tango::Attr> lval(
				new ScalarValueAttrib(attr_name, data_type, w_type, chanNumber));
	
		// -- Scalar attribute properties
		Tango::UserDefaultAttrProp value_prop;
		sprintf(strtmp, "Last Value of Channel %d", chanNumber);
		value_prop.set_description(strtmp);
		lval->set_default_properties(value_prop);
	
		// -- Add scalar attribute
		myds->add_attribute(lval.release());
		if (myds->enableLastValueEvents) {
			myds->set_change_event(attr_name, true, false);
		}
	}
	
	// -- Create spectrum attribute
	{
		sprintf(attr_name, "C%02d_ChannelValues", chanNumber);
		auto_ptr<Tango::Attr> cspec(new ChannelSpectrumAttrib(attr_name, data_type, w_type, LONG_MAX, chanNumber));
	
		// -- Spectrum attribute properties
		Tango::UserDefaultAttrProp value_prop;
		sprintf(strtmp, "Channel %d Buffer", chanNumber);
		value_prop.set_description(strtmp);
		cspec->set_default_properties(value_prop);
	
		// -- Add spectrum attribute
		myds->add_attribute(cspec.release());
		if (myds->enableChannelValueEvents) {
			myds->set_change_event(attr_name, true, false);
		}
	}
	
	/// @todo podria afegir tb un discard full buffer data x tal de descartar les
	/// dades del buffer, no cal tan gran si tota tot el que vull es fer mijes...
	/// Amb el darrer en tinc de sobres... ?
	
	// -- Create mean attribute

	StatsSettings& stats = myds->m_statsSettings;
	
	if (stats.last_mean_enabled) {
		sprintf(attr_name, "C%02d_MeanLast", chanNumber);
		std::auto_ptr<Tango::Attr> lval(new ScalarStatisticAttrib(attr_name, Stats::OperationMean, chanNumber));
		
		myds->add_attribute(lval.release());
		/// @todo mes que change, el ready i tal...
		if (stats.event_last_mean_enabled) {
			myds->set_change_event(attr_name, true, false);
		}
	}

	if (stats.buf_mean_enabled) {
		sprintf(attr_name, "C%02d_MeanValues", chanNumber);
		std::auto_ptr<Tango::SpectrumAttr> lval(new SpectrumStatisticAttrib(attr_name, Stats::OperationMean, chanNumber));

		if (stats.event_buf_mean_data_ready_enabled){
			lval->set_data_ready_event(true);
		}

		myds->add_attribute(lval.release());
		if (stats.event_buf_mean_enabled) {
			myds->set_change_event(attr_name, true, false);
		}

	}

	if (stats.last_std_dev_enabled) {
		sprintf(attr_name, "C%02d_StdDevLast", chanNumber);
		std::auto_ptr<Tango::Attr> lval(new ScalarStatisticAttrib(attr_name, Stats::OperationStdDev, chanNumber));

		myds->add_attribute(lval.release());
		if (stats.event_last_std_dev_enabled) {
			myds->set_change_event(attr_name, true, false);
		}
	}

	if (stats.buf_std_dev_enabled) {
		sprintf(attr_name, "C%02d_StdDevValues", chanNumber);
		std::auto_ptr<Tango::SpectrumAttr> lval(new SpectrumStatisticAttrib(attr_name, Stats::OperationStdDev, chanNumber));

		myds->add_attribute(lval.release());
		if (stats.event_buf_std_dev_enabled) {
			myds->set_change_event(attr_name, true, false);
		}
	}

	if (stats.last_quadratic_mean_enabled) {
		sprintf(attr_name, "C%02d_QuadraticMeanLast", chanNumber);
		std::auto_ptr<Tango::Attr> lval(new ScalarStatisticAttrib(attr_name, Stats::OperationQuadraticMean, chanNumber));

		myds->add_attribute(lval.release());
		if (stats.event_last_quadratic_mean_enabled) {
			myds->set_change_event(attr_name, true, false);
		}
	}

	if (stats.buf_quadratic_mean_enabled) {
		sprintf(attr_name, "C%02d_QuadraticMeanValues", chanNumber);
		std::auto_ptr<Tango::SpectrumAttr> lval(new SpectrumStatisticAttrib(attr_name, Stats::OperationQuadraticMean, chanNumber));

		myds->add_attribute(lval.release());
		if (stats.event_buf_quadratic_mean_enabled) {
			myds->set_change_event(attr_name, true, false);
		}
	}
}



static void addOutputChannelDynamicAttributes(AdlinkAIO *myds, int chanNumber)
{
	char attr_name[50];
	char strtmp[200];

	const long data_type = Tango::DEV_DOUBLE;
	const Tango::AttrWriteType w_type = Tango::READ_WRITE;

	cout << "Creating Output Channel " << chanNumber << endl;

	// -- Create scalar attribute
	{
		sprintf(attr_name, "C%02d_LastValue", chanNumber);
		std::auto_ptr<Tango::Attr> lval(
				new ScalarValueAttrib(attr_name, data_type, w_type, chanNumber));

		// -- Scalar attribute properties
		Tango::UserDefaultAttrProp value_prop;
		sprintf(strtmp, "Last Value of Channel %d", chanNumber);
		value_prop.set_description(strtmp);
		lval->set_default_properties(value_prop);
		lval->set_memorized();
		lval->set_memorized_init(true); /// @todo maybe rethink, to have something compatible with spectrums too...

		// -- Add scalar attribute
		myds->add_attribute(lval.release());
	}

	// -- Create spectrum attribute
	{
		sprintf(attr_name, "C%02d_ChannelValues", chanNumber);
		auto_ptr<Tango::Attr> cspec(new ChannelSpectrumAttrib(attr_name, data_type, w_type, LONG_MAX, chanNumber));

		// -- Spectrum attribute properties
		Tango::UserDefaultAttrProp value_prop;
		sprintf(strtmp, "Channel %d Buffer", chanNumber);
		value_prop.set_description(strtmp);
		cspec->set_default_properties(value_prop);

		// -- Add spectrum attribute
		myds->add_attribute(cspec.release());
	}
}


/// Function that adds dynamic attributes to the devices attributes	 lists
void AdlinkAIOClass::addDynamicAttributes(const Tango::DevVarStringArray *devlist_ptr)
{
	Tango::Util *tg = Tango::Util::instance();
	cout << "DYNAMIC ATTRIBUTES GENERATION ..."  << endl;
	for (unsigned long i=0 ; i < devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *mydev = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		AdlinkAIO *myds = dynamic_cast<AdlinkAIO *> (mydev);
		const int numOfChannels = myds->get_numOfChannels();
		
		std::cout   << "Device: " << (*devlist_ptr)[i] 
					<< ", channels: " << numOfChannels << std::endl;

		if (this->m_isInput) {
			for (int j=0; j<numOfChannels; j++) {
				addInputChannelDynamicAttributes(myds, j);
			}
		} else {
			for (int j=0; j<numOfChannels; j++) {
				addOutputChannelDynamicAttributes(myds, j);
			}
		}
	}
}

}	// namespace
