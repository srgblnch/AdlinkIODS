static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         AdlinkAIO.cpp
//
// description :  C++ source for the AdlinkAIO and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                AdlinkAIO are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: rsune $
//
// $Revision: 8649 $
//
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State       |  dev_state()
//  Status      |  dev_status()
//  Start       |  start()
//  Stop        |  stop()
//  CalibrationAuto | calibration_auto()
//  CalibrationSave | calibration_save()
//  CalibrationLoad | calibration_load()
//  ImportFile  |  import_file()
//  ExportFile  |  export_file()
//
//===================================================================

#include <sys/time.h>

#include "InputBehaviour.h"
#include "OutputBehaviour.h"

#include "tango_utils.h"

#include <AdlinkAIO.h>
#include <AdlinkAIOClass.h>
				 
#include <cctype> // std::tolower
#include <algorithm>

/// @todo Get rid of it ASAP:
/// Includes a trick to implement AutoStart... Needed because NOW Tango does
/// not provide a way to know when all the memorized values have been written
/// back to its attributes after initialization.
#include <MemAttrWriteCheck.cpp>
				 
#define _OCLASSNAME "AdlinkAIO"
#include "odebug.h"

/// For dynamic attributes, extract channel number from attribute name.
#ifdef NDEBUG
#   define CHECK_CHANNEL(channel) (void)0
#else
#   define CHECK_CHANNEL(channel) \
		if (channel < 0) { \
			Tango::Except::throw_exception( \
				"Unreachable attribute", \
				"Template attributes for dynamic attributes like this one" \
				" are not meant to be used directly.", \
				_CFN_); \
		} (void)0
#endif

class ChangeEventListener : public ChangeEventListenerInterface
{
	AdlinkAIO_ns::AdlinkAIO* m_parent;

public:
	ChangeEventListener(AdlinkAIO_ns::AdlinkAIO* parent) : m_parent(parent)
	{ }

	virtual void on_data_changed()
	{
		this->m_parent->on_data_changed();
	}
};

/**
 * @file	AdlinkAIO.cpp 
 * @author	$Author: rsune $
 * @version	$Revision: 8649 $
 */
namespace AdlinkAIO_ns
{

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::AdlinkAIO(string &s)
// 
// description : 	constructor for simulated AdlinkAIO
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
AdlinkAIO::AdlinkAIO(Tango::DeviceClass *cl,string &s)
:AnalogDAQ_ns::AnalogDAQ(cl,s.c_str())
{
	init_device();
}

AdlinkAIO::AdlinkAIO(Tango::DeviceClass *cl,const char *s)
:AnalogDAQ_ns::AnalogDAQ(cl,s)
{
	init_device();
}

AdlinkAIO::AdlinkAIO(Tango::DeviceClass *cl,const char *s,const char *d)
:AnalogDAQ_ns::AnalogDAQ(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::delete_device()
{
	//	Delete device's allocated object
	DEBUG_STREAM << "AdlinkAIO::delete_device()" << endl;

	// Stop tries to change objects value and send an event
	// And it causes problems because attributes no longer exist.
	this->enableLastValueEvents = false;
	this->enableChannelValueEvents = false;

	this->stop();

	this->destroy_buffered_channels_list();

	delete this->adl;
	this->adl = 0;

	delete this->m_changeEventListener;
	this->m_changeEventListener = 0;
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::init_device()
{
	INFO_STREAM << "AdlinkAIO::init_device() " << device_name << endl;

	this->m_isInput = static_cast<AdlinkAIOClass*>(this->get_device_class())->m_isInput;

	// Initialise variables to default values
	//--------------------------------------------
	this->adl = 0;
	this->m_bclList = 0;
	this->m_changeEventListener = 0;
	this->m_statusObserver.adlDev = this;

/// 0. Get property values (or default)
	this->numOfChannels = 1;
	this->useCallbackSignals = true;
	this->useSharedBuffer = true;
	this->onBoardBuffer = 64;
	this->maxSampleRate = 0;
	this->maxSourceRange = 0;
	/// @todo enable*Events properties default to false because:
	///  - Not tested enough
	///  - It is the old expected behaviour
	///  - There may be (not tested) problems because polling may be done
	///    on signal handler time.
	this->enableChannelValueEvents = false;
	this->enableLastValueEvents = false;

	get_device_property();

	m_statsSettings.set_config(this->statsSettings);

	if (this->numOfChannels < 1) {
		this->set_state(Tango::FAULT);
		this->set_status("You MUST set a valid numOfChannels.");
		return;
	}
	
	if ( (!this->boardId.size()) || (!this->boardType.size()) ) {
		this->set_state(Tango::FAULT);
		this->set_status("You have not specified a board ID or boardType.");
		return;
	}

/// 1. Empty attribute values
	{
		attr_SampleRate_write = maxSampleRate;
		attr_Delay_write = 0;
		attr_DelaySource_write = 0;
		attr_ChannelSamplesPerTrigger_write = 1;
		attr_NumOfTriggers_write = 1;
		attr_MaxRefSource_write = maxSourceRange;
		attr_MinRefSource_write = -maxSourceRange;
		attr_TriggerSources_write = 0;
		attr_TriggerMode_write = 0;
		attr_TriggerInfinite_write = 1;
		attr_BufferPeriod_write = 
							(double)attr_ChannelSamplesPerTrigger_write/(double)maxSampleRate;
		attr_BufferedChannelsList_write = 0;
		attr_FileName_write = 0;
		attr_TriggerHighLimit_write = 0.0;
		attr_TriggerLowLimit_write = 0.0;

		attr_SampleRate_read = &attr_SampleRate_write;
		attr_Delay_read = &attr_Delay_write;
		attr_DelaySource_read = &attr_DelaySource_write;
		attr_ChannelSamplesPerTrigger_read = &attr_ChannelSamplesPerTrigger_write;
		attr_NumOfTriggers_read = &attr_NumOfTriggers_write;
		attr_NumOfDisplayableTriggers_read = &attr_NumOfDisplayableTriggers_write;
		attr_MaxRefSource_read = &attr_MaxRefSource_write;
		attr_MinRefSource_read = &attr_MinRefSource_write;
		attr_TriggerHighLimit_read = &attr_TriggerHighLimit_write;
		attr_TriggerLowLimit_read = &attr_TriggerLowLimit_write;
		attr_TriggerSources_read = &attr_TriggerSources_write;
		attr_TriggerMode_read = &attr_TriggerMode_write;
		attr_TriggerInfinite_read = &attr_TriggerInfinite_write;
		attr_BufferPeriod_read = &attr_BufferPeriod_write;
		attr_BufferedChannelsList_read = &attr_BufferedChannelsList_write;
		attr_ScalarValue_read = &attr_ScalarValue_write;
		attr_FileName_read = &attr_FileName_write;
	}

	try {
		AdlinkBase::set_info_stream(&std::cout);
		AdlinkBase::set_error_stream(&std::cerr);

/// 2. Get Parameters from the kind of board	
		const AdlDeviceFactorySingleton::AdlBoardParams* cbp = AdlDeviceFactorySingleton::get_board_params(boardType);
		if(!cbp) {
			std::stringstream ss;
			ss << "The BoardType you specified is not supported by this device server.\n"
			   << "Valid types are:\n";
			std::vector<std::string> boards;
			AdlDeviceFactorySingleton::get_supported_boards(boards);
			std::vector<std::string>::const_iterator i, e=boards.end();
			for (i=boards.begin(); i!=e; ++i) {
				ss << "\t" << *i << std::endl;
			}
			Tango::Except::throw_exception(
						"Unsupported board type",
						ss.str(),
						_CFN_ );
		}

/// 3. Update parameters from device properties
		AdlDeviceFactorySingleton::AdlBoardParams bp;
		this->m_boardParams = *cbp;

		unsigned totalChannels = this->m_isInput?this->m_boardParams.aiChannels:this->m_boardParams.aoChannels;

		if (this->numOfChannels > totalChannels)
			Tango::Except::throw_exception(
						"Invalid number of channels",
						"You have set to this device more channels"
						" than supported by the board itself!",
						_CFN_ );
		this->m_boardParams.totalChannels = this->numOfChannels;

		//this->m_boardParams.timeBase = this->timeBase; // INTERNAL_TIMEBASE
		//this->m_boardParams.minInputScanIntrv = MIN_REF_SOURCE; //this->;
		//this->m_boardParams.maxInputScanIntrv = MAX_REF_SOURCE; // this->
		//this->m_boardParams.dynRange = this->dynamicRange;
		/// @todo dynamicRange property is not really used anymore, and should disappear
		//this->m_boardParams.onBoardBufferSz = this->onBoardBuffer;

/// 4. Initialize adl object 
		if (this->m_isInput)
			this->adl = new InputBehaviour(
									&this->m_boardParams,
									boardId,
									&this->m_statusObserver,
									!this->useSharedBuffer, // can ignore SB
									this->useCallbackSignals, // can use CB
									this->m_statsSettings
								);
		else
			this->adl = new OutputBehaviour(
									&this->m_boardParams,
									boardId,
									&this->m_statusObserver);

		// Initialization of "Change Events", AnalogInput only:
		if (this->m_isInput) {
			// Tell Tango we are implementing LastValues firing of change
			// events. Dynamic attributes (CXX_LastValues and CXX_ChannelValues)
			// still don't exist here. They are also configured this way
			// but when they are created.
			if (this->enableLastValueEvents)
				this->set_change_event("LastValues", true, false);

			// If we want any events, subscribe.
			if (this->enableLastValueEvents || this->enableChannelValueEvents || m_statsSettings.any_enabled()) {
				this->m_changeEventListener = new ChangeEventListener(this);
				InputBehaviour* ib = dynamic_cast<InputBehaviour*>(this->adl);
				ib->subscribe_change_events(this->m_changeEventListener);
			}
		}

/// 5. Give meaningful default values to attributes
		this->adl->range().set_range_id(AD_B_10_V);
		this->adl->adapt_sample_rate(this->attr_SampleRate_write);
		this->attr_SampleRate_write = this->adl->sample_rate();
		this->adl->set_num_of_triggers(attr_NumOfTriggers_write);
		this->adl->set_reference_ground(this->referenceGround);
		
		attr_ChannelSamplesPerTrigger_write = 512;
		this->adl->set_channel_samples_per_trigger(attr_ChannelSamplesPerTrigger_write);
		attr_ChannelSamplesPerTrigger_write = this->adl->channel_samples_per_trigger();
		
		this->build_buffered_channels_list();

/// 6. Set status
		set_state(Tango::STANDBY);
		this->adl->update_status();
		
	} catch (Tango::DevFailed &e) {
		std::stringstream ss;
		ss	<< "Unexpected tango exception:" << std::endl
			<< e << std::endl;
		Tango::Except::print_exception(e);
		this->set_state(Tango::UNKNOWN);
		this->set_status(ss.str());
	} catch (std::exception &e) {
		std::cerr	<< "AdlinkAIO::init_device: exception: !!"
					<< e.what() << std::endl;
		this->set_state(Tango::UNKNOWN);
		this->set_status(e.what());
	} catch (...) {
		std::cerr	<< "AdlinkAIO::init_device: Unexpected exception!!"
					<< std::endl;
		this->set_state(Tango::UNKNOWN);
		this->set_status("Unexpected exception");
	}

/// 7. Check auto start
	MemAttrWriteCheck::init(this);
}



//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("BoardId"));
	dev_prop.push_back(Tango::DbDatum("BoardType"));
	dev_prop.push_back(Tango::DbDatum("OnBoardBuffer"));
	dev_prop.push_back(Tango::DbDatum("MaxSampleRate"));
	dev_prop.push_back(Tango::DbDatum("MaxSourceRange"));
	dev_prop.push_back(Tango::DbDatum("DynamicRange"));
	dev_prop.push_back(Tango::DbDatum("Units"));
	dev_prop.push_back(Tango::DbDatum("NumOfChannels"));
	dev_prop.push_back(Tango::DbDatum("ReferenceGround"));
	dev_prop.push_back(Tango::DbDatum("AutoStart"));
	dev_prop.push_back(Tango::DbDatum("UseCallbackSignals"));
	dev_prop.push_back(Tango::DbDatum("UseSharedBuffer"));
	dev_prop.push_back(Tango::DbDatum("EnableChannelValueEvents"));
	dev_prop.push_back(Tango::DbDatum("EnableLastValueEvents"));
	dev_prop.push_back(Tango::DbDatum("StatsSettings"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	AdlinkAIOClass	*ds_class =
		(static_cast<AdlinkAIOClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize BoardId from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  boardId;
	//	Try to initialize BoardId from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  boardId;
	//	And try to extract BoardId value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  boardId;

	//	Try to initialize BoardType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  boardType;
	//	Try to initialize BoardType from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  boardType;
	//	And try to extract BoardType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  boardType;

	//	Try to initialize OnBoardBuffer from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  onBoardBuffer;
	//	Try to initialize OnBoardBuffer from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  onBoardBuffer;
	//	And try to extract OnBoardBuffer value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  onBoardBuffer;

	//	Try to initialize MaxSampleRate from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  maxSampleRate;
	//	Try to initialize MaxSampleRate from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  maxSampleRate;
	//	And try to extract MaxSampleRate value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxSampleRate;

	//	Try to initialize MaxSourceRange from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  maxSourceRange;
	//	Try to initialize MaxSourceRange from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  maxSourceRange;
	//	And try to extract MaxSourceRange value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxSourceRange;

	//	Try to initialize DynamicRange from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  dynamicRange;
	//	Try to initialize DynamicRange from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  dynamicRange;
	//	And try to extract DynamicRange value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dynamicRange;

	//	Try to initialize Units from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  units;
	//	Try to initialize Units from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  units;
	//	And try to extract Units value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  units;

	//	Try to initialize NumOfChannels from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  numOfChannels;
	//	Try to initialize NumOfChannels from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  numOfChannels;
	//	And try to extract NumOfChannels value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  numOfChannels;

	//	Try to initialize ChannelsAlias from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  referenceGround;
	//	Try to initialize ReferenceGround from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  referenceGround;
	//	And try to extract ReferenceGround value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  referenceGround;

	//	Try to initialize AutoStart from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoStart;
	//	Try to initialize AutoStart from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  autoStart;
	//	And try to extract AutoStart value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoStart;

	//	Try to initialize UseCallbackSignals from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  useCallbackSignals;
	//	Try to initialize UseCallbackSignals from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  useCallbackSignals;
	//	And try to extract UseCallbackSignals value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useCallbackSignals;

	//	Try to initialize UseSharedBuffer from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  useSharedBuffer;
	//	Try to initialize UseSharedBuffer from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  useSharedBuffer;
	//	And try to extract UseSharedBuffer value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useSharedBuffer;

	//	Try to initialize EnableChannelValueEvents from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableChannelValueEvents;
	//	Try to initialize EnableChannelValueEvents from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  enableChannelValueEvents;
	//	And try to extract EnableChannelValueEvents value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableChannelValueEvents;

	//	Try to initialize EnableLastValueEvents from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  enableLastValueEvents;
	//	Try to initialize EnableLastValueEvents from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  enableLastValueEvents;
	//	And try to extract EnableLastValueEvents value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  enableLastValueEvents;

	//	Try to initialize StatsSettings from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  statsSettings;
	//	Try to initialize StatsSettings from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  statsSettings;
	//	And try to extract StatsSettings value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statsSettings;

	//	End of Automatic code generation
	//------------------------------------------------------------------
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void AdlinkAIO::always_executed_hook()
{
	this->lets_change_state();
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "AdlinkAIO::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_SampleRate
// 
// description : 	Extract real attribute values for SampleRate acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_SampleRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_SampleRate(Tango::Attribute &attr) entering... "<< endl;
	this->attr_SampleRate_write = this->adl->sample_rate();
	attr.set_value(attr_SampleRate_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_SampleRate
// 
// description : 	Write SampleRate attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_SampleRate(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_SampleRate(Tango::WAttribute &attr) entering... " << endl;

	attr.get_write_value(attr_SampleRate_write);

	this->update_sample_rate();
	this->adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_Delay
// 
// description : 	Extract real attribute values for Delay acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_Delay(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_Delay(Tango::Attribute &attr) entering... "<< endl;
	this->attr_Delay_write = this->adl->delay();
	attr.set_value(attr_Delay_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_Delay
// 
// description : 	Write Delay attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_Delay(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_Delay(Tango::WAttribute &attr) entering... " << endl;
	attr.get_write_value(attr_Delay_write);
	this->adl->set_delay(attr_Delay_write);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_DelaySource
// 
// description : 	Extract real attribute values for DelaySource acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_DelaySource(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_DelaySource(Tango::Attribute &attr) entering... "<< endl;
	switch(this->adl->delay_source()) {
		case DelayTimebase:
			this->attr_DelaySource_write = 0;
			break;
		case DelaySamples:
			this->attr_DelaySource_write = 1;
			break;
		default:
			Tango::Except::throw_exception(
			                  "Invalid_DelaySource",
			                  "Probably a programming mistake,"
			                  " contact developer.",
			                  _CFN_);
			return;
	}
	attr.set_value(attr_DelaySource_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_DelaySource
// 
// description : 	Write DelaySource attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_DelaySource(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_DelaySource(Tango::WAttribute &attr) entering... " << endl;
	attr.get_write_value(attr_DelaySource_write);
	switch(attr_DelaySource_write) {
		case 0:
			this->adl->set_delay_source(DelayTimebase);
			break;
		case 1:
			this->adl->set_delay_source(DelaySamples);
			break;
		default:
			Tango::Except::throw_exception(
			         "Bad_Param",
			         "Valid values are:\n"
			         "  - 0: Timebase\n"
			         "  - 1: Samples\n",
			         _CFN_);
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_ChannelSamplesPerTrigger
// 
// description : 	Extract real attribute values for ChannelSamplesPerTrigger acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_ChannelSamplesPerTrigger(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_ChannelSamplesPerTrigger(Tango::Attribute &attr) entering... " << endl;
	attr_ChannelSamplesPerTrigger_write = this->adl->channel_samples_per_trigger();
	attr.set_value(attr_ChannelSamplesPerTrigger_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_ChannelSamplesPerTrigger
// 
// description : 	Write ChannelSamplesPerTrigger attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_ChannelSamplesPerTrigger(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_ChannelSamplesPerTrigger(Tango::WAttribute &attr) entering... " << endl;

 	assert (get_state() == Tango::STANDBY);
	assert (this->adl->get_state() == BaseBehaviour::StateNone);
	
	attr.get_write_value(attr_ChannelSamplesPerTrigger_write);
	
	if ( attr_ChannelSamplesPerTrigger_write <= 0 ) {
		attr_ChannelSamplesPerTrigger_write = this->adl->channel_samples_per_trigger();
		Tango::Except::throw_exception(
							"Can\'t change ChannelSamplesPerTrigger",
							"It must be a positive integer.",
							_CFN_);
	}
	this->adl->set_channel_samples_per_trigger(attr_ChannelSamplesPerTrigger_write);
	attr_ChannelSamplesPerTrigger_write = this->adl->channel_samples_per_trigger();
	
 	this->adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_NumOfTriggers
// 
// description : 	Extract real attribute values for NumOfTriggers acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_NumOfTriggers(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_NumOfTriggers(Tango::Attribute &attr) entering... "<< endl;
	attr.set_value(attr_NumOfTriggers_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_NumOfTriggers
// 
// description : 	Write NumOfTriggers attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_NumOfTriggers(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_NumOfTriggers(Tango::WAttribute &attr) entering... "<< endl;
	assert(get_state() == Tango::STANDBY);
	assert (this->adl->get_state() == BaseBehaviour::StateNone);
	
	attr.get_write_value(attr_NumOfTriggers_write);
	this->adl->set_num_of_triggers(attr_NumOfTriggers_write);
	attr_NumOfTriggers_write = this->adl->num_of_triggers();

	this->adl->update_status();
}


//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_NumOfDisplayableTriggers
//
// description : 	Extract real attribute values for NumOfDisplayableTriggers acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_NumOfDisplayableTriggers(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_NumOfDisplayableTriggers(Tango::Attribute &attr) entering... " << endl;
	assert(this->m_isInput);
	InputBehaviour* adl = static_cast<InputBehaviour*>(this->adl);
	
	*attr_NumOfDisplayableTriggers_read = adl->get_num_of_displayable_triggers();
	attr.set_value(attr_NumOfDisplayableTriggers_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_NumOfDisplayableTriggers
//
// description : 	Write NumOfDisplayableTriggers attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_NumOfDisplayableTriggers(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_NumOfDisplayableTriggers(Tango::WAttribute &attr) entering... " << endl;
	assert(get_state() == Tango::STANDBY);
	assert (this->adl->get_state() == BaseBehaviour::StateNone);

	assert(this->m_isInput);
	InputBehaviour* adl = static_cast<InputBehaviour*>(this->adl);
	
	attr.get_write_value(attr_NumOfDisplayableTriggers_write);

	if ((attr_NumOfDisplayableTriggers_write < 1) && (attr_NumOfDisplayableTriggers_write != -1) ) {
				Tango::Except::throw_exception(
							"Bad value",
							"NumOfDisplayableTriggers must be a positive integer or -1(then it's is internally set to NumOfTriggers).",
							_CFN_);
	}

	adl->set_num_of_displayable_triggers(attr_NumOfDisplayableTriggers_write);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_MaxRefSource
// 
// description : 	Extract real attribute values for MaxRefSource acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_MaxRefSource(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_MaxRefSource(Tango::Attribute &attr) entering... "<< endl;
	double min, max;
	if(this->adl->range().get_next_min_max_range(min, max)) {
		*attr_MaxRefSource_read = max;
		attr.set_value(attr_MaxRefSource_read);
	} else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_MaxRefSource
// 
// description : 	Write MaxRefSource attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_MaxRefSource(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_MaxRefSource(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(attr_MaxRefSource_write);
	adl->range().set_next_max_range(attr_MaxRefSource_write);
	this->adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_MinRefSource
// 
// description : 	Extract real attribute values for MinRefSource acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_MinRefSource(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_MinRefSource(Tango::Attribute &attr) entering... "<< endl;
	double min, max;
	if(this->adl->range().get_next_min_max_range(min, max)) {
		*attr_MinRefSource_read = min;
		attr.set_value(attr_MinRefSource_read);
	} else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_MinRefSource
// 
// description : 	Write MinRefSource attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_MinRefSource(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_MinRefSource(Tango::WAttribute &attr) entering... "<< endl;
	INFO_STREAM << "MinRefSource writing not allowed in this version ..." << endl;
	attr.get_write_value(attr_MinRefSource_write);
	adl->range().set_next_min_range(attr_MinRefSource_write);
	adl->update_status();
}


//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_TriggerHighLimit
// 
// description : 	Extract real attribute values for TriggerHighLimit acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_TriggerHighLimit(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_TriggerHighLimit(Tango::Attribute &attr) entering... "<< endl;

	if (!this->adl->trigger_mode().editable_low_high(0)) {
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	*attr_TriggerHighLimit_read = this->adl->trigger_mode().analog_high();
	
	attr.set_value(attr_TriggerHighLimit_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_TriggerHighLimit
// 
// description : 	Write TriggerHighLimit attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_TriggerHighLimit(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_TriggerHighLimit(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(this->attr_TriggerHighLimit_write);

	// I say "can't write" but I am writing it... Why? Well, we ust tell the
	// user that what they are doing is pointless, but we must be ready for
	// the initialisation order of tango. As I am not sure if TriggerSources
	// will or won't be initialized before TriggerXXLimit, so in this way
	// we make sure it works still..
	this->adl->trigger_mode().set_analog_high(attr_TriggerHighLimit_write);
	
	if (!this->adl->trigger_mode().editable_low_high(0)) {
		Tango::Except::throw_exception (
					"Can't write analog trigger high limit.",
					"It only makes sense if the trigger source is one of: "
					"\n\tANA:above-high"
					"\n\tANA:inside-region"
					"\n\tANA:low-hysteresis"
					"\n\tANA:high-hysteresis",
					_CFN_ );
	}

	adl->update_status();
}


//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_TriggerLowLimit
// 
// description : 	Extract real attribute values for TriggerLowLimit acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_TriggerLowLimit(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_TriggerLowLimit(Tango::Attribute &attr) entering... "<< endl;

	if (!this->adl->trigger_mode().editable_low_high(1)) {
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	*attr_TriggerLowLimit_read = this->adl->trigger_mode().analog_low();
	
	attr.set_value(attr_TriggerLowLimit_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_TriggerLowLimit
// 
// description : 	Write TriggerLowLimit attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_TriggerLowLimit(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_TriggerLowLimit(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(this->attr_TriggerLowLimit_write);

	// I say "can't write" but I am writing it... Why? Well, we ust tell the
	// user that what they are doing is pointless, but we must be ready for
	// the initialisation order of tango. As I am not sure if TriggerSources
	// will or won't be initialized before TriggerXXLimit, so in this way
	// we make sure it works still..
	this->adl->trigger_mode().set_analog_low(attr_TriggerLowLimit_write);
	
	if (!this->adl->trigger_mode().editable_low_high(1)) {
		Tango::Except::throw_exception (
					"Can't write analog trigger low limit.",
					"It only makes sense if the trigger source is one of: "
					"\n\tANA:below-low"
					"\n\tANA:inside-region"
					"\n\tANA:low-hysteresis"
					"\n\tANA:high-hysteresis",
					_CFN_ );
	}

	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_TriggerSources
// 
// description : 	Extract real attribute values for TriggerSources acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_TriggerSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_TriggerSources(Tango::Attribute &attr) entering... "<< endl;

	this->adl->trigger_mode().trigger_source_string(this->triggerSourceString);
	*attr_TriggerSources_read = (Tango::DevString)this->triggerSourceString.c_str();

	attr.set_value(attr_TriggerSources_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_TriggerSources
// 
// description : 	Write TriggerSources attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_TriggerSources(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_TriggerSources(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(this->attr_TriggerSources_write);
	
	if (!this->adl->trigger_mode().parse_trigger_source(this->attr_TriggerSources_write)) {
		Tango::Except::throw_exception (
					"Invalid trigger source",
					"Valid values are: "
					"\n\tSOFT    (default)"
					"\n\tExtD:+"
					"\n\tExtD:-"
					"\n\tSSI"
					"\n\tANA:below-low"
					"\n\tANA:above-high"
					"\n\tANA:inside-region"
					"\n\tANA:low-hysteresis"
					"\n\tANA:high-hysteresis",
					_CFN_ );
	}

	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_TriggerMode
// 
// description : 	Extract real attribute values for TriggerMode acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_TriggerMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_TriggerMode(Tango::Attribute &attr) entering... "<< endl;
	
	*attr_TriggerMode_read =
			this->adl->trigger_mode().get_trigger_mode(this->adl->is_input());
	attr.set_value(attr_TriggerMode_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_TriggerMode
// 
// description : 	Write TriggerMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_TriggerMode(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_TriggerMode(Tango::WAttribute &attr) entering... "<< endl;

	attr.get_write_value(attr_TriggerMode_write);

	if (!this->adl->trigger_mode().set_trigger_mode(
							attr_TriggerMode_write, this->adl->is_input()) )
		if (this->adl->is_input())
			Tango::Except::throw_exception (
					"Cant set trigger mode",
					"Valid values for input devices are: "
					"\n\t0 POST"
					"\n\t1 DELAY"
					"\n\t2 PRE"
					"\n\t3 MIDL",
					_CFN_ );
		else
			Tango::Except::throw_exception (
					"Cant set trigger mode",
					"Valid values for output devices are: "
					"\n\t0 POST"
					"\n\t1 DELAY",
					_CFN_ );

	adl->update_status();
}


//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_TriggerInfinite
// 
// description : 	Extract real attribute values for TriggerInfinite acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_TriggerInfinite(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_TriggerInfinite(Tango::Attribute &attr) entering... "<< endl;
	
	*attr_TriggerInfinite_read = this->adl->infinite_retrigger();
	attr.set_value(attr_TriggerInfinite_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_TriggerInfinite
// 
// description : 	Write TriggerInfinite attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_TriggerInfinite(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_TriggerInfinite(Tango::WAttribute &attr) entering... "<< endl;

	attr.get_write_value(attr_TriggerInfinite_write);

	this->adl->set_infinite_retrigger(attr_TriggerInfinite_write);
	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_BufferPeriod
// 
// description : 	Extract real attribute values for BufferPeriod acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_BufferPeriod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_BufferPeriod(Tango::Attribute &attr) entering... "<< endl;
	attr_BufferPeriod_write = (double)this->adl->channel_samples_per_trigger()/(double)this->adl->sample_rate();
	attr.set_value(attr_BufferPeriod_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_BufferPeriod
// 
// description : 	Write BufferPeriod attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_BufferPeriod(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_BufferPeriod(Tango::WAttribute &attr) entering... "<< endl;

	attr.get_write_value(attr_BufferPeriod_write);

	attr_SampleRate_write = long(this->adl->channel_samples_per_trigger()/attr_BufferPeriod_write);

	this->update_sample_rate();
	this->adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_BufferedChannelsList
// 
// description : 	Extract real attribute values for BufferedChannelsList acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_BufferedChannelsList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_BufferedChannelsList(Tango::Attribute &attr) entering... "<< endl;
	
	attr.set_value(this->m_bclList, this->m_bclTotal, 0); 
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_BufferedChannelsList
// 
// description : 	Write BufferedChannelsList attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_BufferedChannelsList(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_BufferedChannelsList(Tango::WAttribute &attr) entering... "<< endl;
	INFO_STREAM << "BufferedChannelsList writing not allowed in this version ..." << endl;
	adl->update_status();

	Tango::Except::throw_exception(
			"Unable to write BufferedChannelsList",
			"This is not supported in this version",
			_CFN_);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_RawDATA
// 
// description : 	Extract real attribute values for RawDATA acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_RawDATA(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_RawDATA(Tango::Attribute &attr) entering... "<< endl;

	long *image;
	long x, y;
	struct timeval time;

	if (this->adl->read_raw_data(image, x, y, time))
		attr.set_value_date_quality(image, time, Tango::ATTR_VALID, x, y);
	else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_RawDATA
// 
// description : 	Write RawDATA attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_RawDATA(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_RawDATA(Tango::WAttribute &attr) entering... "<< endl;
	INFO_STREAM << "RawDATA writing not allowed in this version ..." << endl;
	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_DoubleDATA
// 
// description : 	Extract real attribute values for DoubleDATA acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_DoubleDATA(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_DoubleDATA(Tango::Attribute &attr) entering... "<< endl;

	BaseBehaviour::volts_type* image;
	long x, y;
	struct timeval time;

	if (this->adl->read_double_data(image, x, y, time))
		attr.set_value_date_quality(image, time, Tango::ATTR_VALID, x, y);
	else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_DoubleDATA
// 
// description : 	Write DoubleDATA attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_DoubleDATA(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_DoubleDATA(Tango::WAttribute &attr) entering... "<< endl;
	INFO_STREAM << "DoubleDATA writing not allowed in this version ..." << endl;
	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_FileName
// 
// description : 	Extract real attribute values for FileName acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_FileName(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_FileName(Tango::Attribute &attr) entering... "<< endl;
	if (*attr_FileName_read)
		attr.set_value(attr_FileName_read);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_FileName
// 
// description : 	Write FileName attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_FileName(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_FileName(Tango::WAttribute &attr) entering... "<< endl;
	attr.get_write_value(attr_FileName_write);
	adl->update_status();
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_SpectrumStatistic
//
// description : 	Extract real attribute values for SpectrumStatistic acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_SpectrumStatistic(Tango::Attribute &attr, Stats::SelectedOperation op, int channel)
{
	DEBUG_STREAM << "AdlinkAIO::read_SpectrumStatistic(Tango::Attribute &attr: '"<<attr.get_name()<<"', " << op << ", "<< channel <<") entering... "<< endl;

	assert(this->m_isInput);
	InputBehaviour* adl = static_cast<InputBehaviour*>(this->adl);

	const double* data;
	size_t dim_x;
	struct timeval time;

	if(adl->m_statsCalculator.get_last_buffer(op, channel, data, dim_x, time)) {
		attr.set_value_date_quality(const_cast<double*>(data), time, Tango::ATTR_VALID, dim_x);
	} else {
		attr.set_quality(Tango::ATTR_INVALID);
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_ScalarStatistic
//
// description : 	Extract real attribute values for ScalarStatistic acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_ScalarStatistic(Tango::Attribute &attr, Stats::SelectedOperation op, int channel)
{
	DEBUG_STREAM << "AdlinkAIO::read_ScalarStatistic(Tango::Attribute &attr: '"<<attr.get_name()<<"', " << op << ", "<< channel <<") entering... "<< endl;

	assert(this->m_isInput);
	InputBehaviour* adl = static_cast<InputBehaviour*>(this->adl);

	struct timeval time;

	if(adl->m_statsCalculator.get_last(op, channel, this->attr_ScalarStatistic_read, time)) {
		attr.set_value_date_quality(&this->attr_ScalarStatistic_read, time, Tango::ATTR_VALID);
	} else {
		attr.set_quality(Tango::ATTR_INVALID);
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_ScalarValue
// 
// description : 	Extract real attribute values for ScalarValue acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_ScalarValue(Tango::Attribute &attr, int channel)
{
	DEBUG_STREAM << "AdlinkAIO::read_ScalarValue(Tango::Attribute &attr: '"<<attr.get_name()<<"') entering... "<< endl;

	CHECK_CHANNEL(channel);

	BaseBehaviour::volts_type *value;
	struct timeval time;

	if (this->adl->read_scalar_value(channel, value, time))
		attr.set_value_date_quality(value, time, Tango::ATTR_VALID);
	else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_ScalarValue
// 
// description : 	Write ScalarValue attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_ScalarValue(Tango::WAttribute &attr, int channel)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM	<< "AdlinkAIO::write_ScalarValue(Tango::WAttribute &attr: '"
					<< attr.get_name() << "') entering... "<< endl;
    
	if(this->adl->is_input())
        Tango::Except::throw_exception(
            "Unable to write CXX_LastValue. In an input device, it is not writable.",
            "Not_allowed",
			_CFN_ );
	
	CHECK_CHANNEL(channel);

	BaseBehaviour::volts_type res;
	attr.get_write_value(res);

	if (!this->adl->write_scalar_value(channel, res) )
		Tango::Except::throw_exception(
			"Unable to write CXX_LastValue, there's been an error when trying to do so.",
			"Error_writing",
			_CFN_ );
}



//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_LastValues
// 
// description : 	Extract real attribute values for LastValues acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_LastValues(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkAIO::read_LastValues entering... "<< endl;

	BaseBehaviour::volts_type* data;
	long x;
	struct timeval time;

	if (this->adl->read_last_values(data, x, time))
		attr.set_value_date_quality(data, time, Tango::ATTR_VALID, x);
	else
		attr.set_quality(Tango::ATTR_INVALID);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::write_LastValues
// 
// description : 	Write LastValues attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::write_LastValues(Tango::WAttribute &attr)
{
	MemAttrWriteCheck mawc(this, attr);
	DEBUG_STREAM << "AdlinkAIO::write_LastValues () entering... " << endl;

	if (this->adl->is_input())
		Tango::Except::throw_exception(
			"Unable to write ChannelSpectrum. Device is configured as INPUT",
			"Not_allowed",
			_CFN_);

	const BaseBehaviour::volts_type* res;
 	size_t szRead = attr.get_write_value_length();

	if (szRead > this->adl->nchannels()) {
		Tango::Except::throw_exception(
							"Cant write channel values. Too many values for not enough channels",
							"Too many values for not enough channels",
							_CFN_ );
	}
    attr.get_write_value(res);

	if (!this->adl->write_last_values(res, szRead) )
		Tango::Except::throw_exception(
			"Unable to write LastValues",
			"Error while trying to write last values",
			_CFN_);
}




//+----------------------------------------------------------------------------
//
// method : 		AdlinkAIO::read_ChannelSpectrum
// 
// description : 	Extract real attribute values for ChannelSpectrum acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkAIO::read_ChannelSpectrum(Tango::Attribute &attr, int channel)
{
	DEBUG_STREAM << "AdlinkAIO::read_ChannelSpectrum(Tango::Attribute &attr: '"<<attr.get_name()<<"') entering... "<< endl;

	CHECK_CHANNEL(channel);

	BaseBehaviour::volts_type* data;
	long x;
	struct timeval time;

	if (this->adl->read_channel_spectrum(channel, data, x, time)) {
        //std::cout << "pos el read_channel_spectrum esta fet" << endl;
		attr.set_value_date_quality(data, time, Tango::ATTR_VALID, x);
        //std::cout << "pos el set_value_date_quality esta fet" << endl;
    } else
		attr.set_quality(Tango::ATTR_INVALID);
}
//+----------------------------------------------------------------------------
/** 
 * method : 		AdlinkAIO::write_ChannelSpectrum
 * description : 	Write ChannelSpectrum attribute values to hardware.
 *
 */
//-----------------------------------------------------------------------------
void AdlinkAIO::write_ChannelSpectrum(Tango::WAttribute &attr, int channel)
{
	MemAttrWriteCheck mawc(this, attr);
	INFO_STREAM << "AAdlinkAIO::write_ChannelSpectrum(Tango::WAttribute &attr: '"
				<< attr.get_name() << "') entering... " << endl;
	
	if (this->adl->is_input())
		Tango::Except::throw_exception(
			"Unable to write ChannelSpectrum",
			"Device is configured as INPUT",
			_CFN_ );
	
	CHECK_CHANNEL(channel);

	const BaseBehaviour::volts_type* data;
	attr.get_write_value(data);
	long len = attr.get_write_value_length();

	if (!this->adl->write_channel_spectrum(channel, data, len) )
		Tango::Except::throw_exception(
			"Unable to write ChannelSpectrum",
			"Error while trying to write last values",
			_CFN_ );
}


//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::start
 *
 *	description:	method to execute "Start"
 *	This Command will start the acquisition and will change the State to RUNNING.<br>
 *	It will register the hardware device if the previous state was STANDBY <br>
 *	The change from RUNNING State to ON is performed inside the always_executed_hook method..<br>
 *	If the device server is in state ON the acquisition is restarted w/out reconfiguring the device.<br>
 *
 *
 */
//+------------------------------------------------------------------
void AdlinkAIO::start()
{
	DEBUG_STREAM << "AdlinkAIO::start(): entering... !" << endl;

	// We make sure this->adl is defined in the state so it seems
	// unnecessary to check here. But it is still needed because
	// "AutoStart" calls AdlinkAIO::start without bothering about
	// the current device state.
	if (this->adl) {
		this->adl->start();
		this->adl->update_status();
	}
}


//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::stop
 *
 *	description:	method to execute "Stop"
 *	It Stops all the acquisition process, unregisters the Hardware device and sets the State to STANDBY. <br>
 *	It's the only way to unblock the device from FAULT State to STANDBY.
 *
 *
 */
//+------------------------------------------------------------------
void AdlinkAIO::stop()
{
	DEBUG_STREAM << "AdlinkAIO::stop(): entering... !" << endl;

	if (this->adl) {
		this->adl->stop();
		this->adl->update_status();
	}
}


//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::calibration_auto
 *
 *	description:	method to execute "CalibrationAuto"
 *	Runs the auto calibration function of the board(if available).
 *  ACHTUNG: It needs exclusive access to the board, so it will kill
 *  any other device running in this device server.
 *
 * @return	Ok
 *
 */
//+------------------------------------------------------------------
void AdlinkAIO::calibration_auto()
{
	DEBUG_STREAM << "AdlinkAIO::auto_calibration(): entering... !" << endl;
	
	///
	/// In order to perform the calibration, we want exclusive access to the
	/// device. So, we will KILL any other device running in this server
	/// (ex: an AdlinkAIO for input if this is output, or a DIO...)
	/// except for this device itself and the dserver.
	///
	
	if (!this->adl)
		return;		
	
	Tango::DServer* dserver = Tango::Util::instance()->get_dserver_device();
	
	std::string name(this->get_name());
	std::transform(name.begin(), name.end(), name.begin(), ::tolower);
	
	std::string dserver_name(dserver->get_name());
	std::transform(dserver_name.begin(), dserver_name.end(), dserver_name.begin(), ::tolower);
	
	Tango::DeviceClass* dev_class;
	
	std::vector<std::string> deleted_name;
	std::vector<Tango::DeviceClass*> deleted_class;
	
	{
		vector<Tango::DeviceImpl*> devices = Tango::Util::instance()->get_device_list("*");
		vector<Tango::DeviceImpl*>::iterator i, e = devices.end();
		for (i=devices.begin(); i != e; ++i ) {
			std::string dev_name((*i)->get_name());
			std::transform(dev_name.begin(), dev_name.end(), dev_name.begin(), ::tolower);
			
			if ((dev_name == name) || (dev_name == dserver_name) )
				continue;
			
			INFO_STREAM << _CFN_ << "KILLING DEVICE: " << dev_name << std::endl;
			
			deleted_name.push_back(dev_name);
			deleted_class.push_back((*i)->get_device_class());
			
			(*i)->get_device_class()->device_destroyer(dev_name);
		}
	}
	
	/// Now we are the only device running on this server, we can safely
	/// run the calibration function...
		
	/// @todo pos apa, fer-ho...
	/// @todo cal un parametre, a quina posicio es guardenla calibracio
	/// @todo i tb cal una propietat que indiqui de quina posicio carregar-los a l'iniciar el DS, si es que ho vull...
	/// @todo propietat que ha de ser al dserver, i carregada no tinc clar quant ni com...
	/// I16 D2K_Load_CAL_Data (U16 CardNumber, U16 bank)
	/// I16 D2K_EEPROM_CAL_Constant_Update(U16 wCardNumber, U16 bank) 
	/// I16 D2K_DB_Auto_Calibration_ALL(U16 CardNumber)
	try {
		this->adl->perform_auto_calibration();
		
#define __CALIBRATION_END() \
		/* \
			Ok, so our job is done. Time to restore the original devices \
			that I deleted to have exclusive access, back in place... \
		*/ \
		for (size_t n =0; n < deleted_name.size(); ++n) { \
			Tango::DevVarStringArray todel(1); \
			todel.length(1); \
			todel[0] = CORBA::string_dup(deleted_name[n].c_str()); \
			\
			INFO_STREAM << _CFN_ << "RECREATING: " << deleted_name[n] << std::endl; \
			deleted_class[n]->device_factory(&todel); \
		}
	} catch(...) {
		__CALIBRATION_END();
		throw;
	}
	__CALIBRATION_END();
#undef __CALIBRATION_END
}

//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::calibration_save
 *
 *	description:	method to execute "CalibrationAuto"
 *  Saves the current calibration settings into the EEPROM. See the board
 *  documentation. You can use CalibrationAuto previously to set these settings
 *  and CalibrationLoad to restore from the EEPROM.
 *  @param bank EEPROM storage bank number, 0 to 3.
 *
 * @return	Ok
 *
 */
//+------------------------------------------------------------------
void AdlinkAIO::calibration_save(Tango::DevULong bank)
{
	this->adl->save_calibration_settings(bank);
}

//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::calibration_load
 *
 *	description:	method to execute "CalibrationAuto"
 *  Restore the calibration settings saved with CalibrationSave.
 *  @param bank EEPROM storage bank number, 0 to 3.
 *
 * @return	Ok
 *
 */
//+------------------------------------------------------------------
void AdlinkAIO::calibration_load(Tango::DevULong bank)
{
	this->adl->load_calibration_settings(bank);
}

//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::import_file
 *
 *	description:	method to execute "ImportFile"
 *	It imports inside the rawData buffer the contents of the file designed by FileName Attribute
 *
 * @return	Ok
 *
 */
//+------------------------------------------------------------------
Tango::DevBoolean AdlinkAIO::import_file()
{
	DEBUG_STREAM << "AdlinkAIO::import_file(): entering... !" << endl;

	std::ifstream is(attr_FileName_write);
	if(!is)
		return false;
	this->adl->import_stream(is);
	this->adl->update_status();
	return true;
}

//+------------------------------------------------------------------
/**
 *	method:	AdlinkAIO::export_file
 *
 *	description:	method to execute "ExportFile"
 *	It exports the full rawData buffer buffer contents to a file designed by FileName Attribute
 *
 * @return	Ok
 *
 */
//+------------------------------------------------------------------
Tango::DevBoolean AdlinkAIO::export_file()
{
	DEBUG_STREAM << "AdlinkAIO::export_file(): entering... !" << endl;

	std::ofstream os(attr_FileName_write);
	if(!os)
		return false;
	this->adl->export_stream(os);
	return true;
}



void AdlinkAIO::update_sample_rate()
{
	this->adl->adapt_sample_rate(this->attr_SampleRate_write);
	this->attr_SampleRate_write = this->adl->sample_rate();
}

void AdlinkAIO::destroy_buffered_channels_list()
{
	size_t total = this->numOfChannels;
	char ** r = this->m_bclList;
	this->m_bclTotal = 0;
	
	if (!r)
		return;

	for (size_t n = 0; n < total; ++n) {
		delete [] r[n];
	}
	delete [] r;
}

void AdlinkAIO::build_buffered_channels_list()
{
	size_t total = this->numOfChannels;

	const char ai[] = "AI-%02d";
	const char ao[] = "AO-%02d";
	const char *ax = ao;
	if (this->m_isInput)
		ax = ai;

	char **r = 0;
	size_t n = 0;
	this->m_bclTotal = 0;
	this->m_bclList = 0;

	try {
		r = new char*[total];
		for (; n < total; ++n) {
			r[n] = 0;
			if (true) {
				/// @todo Some devices should be able to select which of
				/// the inputs of the range are REALLY being used, not just
				/// all of them
				this->m_bclTotal += 1;
				r[n] = new char[10];
				sprintf(r[n], ax, n);
			}
		}
		this->m_bclList = r;
	} catch (...) {
		for (; n>=0; --n)
			delete [] r[n];
		delete [] r;
		this->m_bclTotal = 0;
		throw;
	}
}


void AdlinkAIO::signal_handler(long signo)
{
	// We have prevented Tango from getting the signals itself, so
	// we should NEVER get here. see AdlinkAIOClass constructor and
	// destructor
	assert(false);
}

void AdlinkAIO::lets_change_status(const std::string & st)
{
	std::stringstream ss;
	this->lets_change_state(true);
	Tango::DevState dstate=this->get_state();
	ss << "The State is " << Tango::DevStateName[dstate] << std::endl << st;
	this->set_status(ss.str());
}

void AdlinkAIO::lets_change_state(bool fromStatus)
{
	// Error states: We stay there
	if ( (get_state()==Tango::UNKNOWN) || (get_state()==Tango::FAULT) )
		return;

	if (!fromStatus)
		this->adl->update_state_fast();
	BaseBehaviour::OperationState st = this->adl->get_state();

	switch(st)
	{
		case BaseBehaviour::StateFault:
			// If we are updating the state from always execute hook and
			// get here, it probably means the status has not been updated
			// to show the reason of the FAULT (Because lets_update_status())
			// does come here, so ask him to d it now.
			if (!fromStatus)
				this->adl->update_status();
			this->set_state(Tango::FAULT);
			break;
		case BaseBehaviour::StateNone:
			this->set_state(Tango::STANDBY);
			break;
		case BaseBehaviour::StateRegistered:
		case BaseBehaviour::StateReady:
			this->set_state(Tango::ON);
			break;
		case BaseBehaviour::StateRunning:
			this->set_state(Tango::RUNNING);
			break;
		default:
			assert(false);
	}
}

///
/// When InputBehaviour knows there is new data available it will (if
/// the callback is registered) notify the device this way so it can
/// push events if needed.
/// 
/// Now these events are sent directly from the signal handler
/// or the polling thread were they are generated. Check if it is
/// problematic if it takes too long, specially if we are using signal
/// handlers. If it is, we could use a new thread and wake it up from
/// here. Otherwise, it seems a good idea to also "disable shared buffer"
/// when using it.
///
void AdlinkAIO::on_data_changed()
{
	assert(this->m_isInput);

	InputBehaviour* adl = static_cast<InputBehaviour*>(this->adl);

	adl->m_statsCalculator.calc_stats(adl);

	if (this->enableChannelValueEvents || this->enableLastValueEvents || m_statsSettings.event_any_enabled())
		this->push_change_events();
}

///
/// It pushes change events according to the attribute selection
/// of events (by properties):
/// if enableLastValueEvents:
///    CXX_LastValue scalar attributes
///    LastValues spectrum attribute
/// if enableChannelValueEvents:
///    CXX_ChannelValues
///
/// It is only used by Analog Input
///
void AdlinkAIO::push_change_events()
{
	assert(this->m_isInput);
	struct timeval lastAcqTime;

	/// @todo use DataReady events instead of CHANGE events... ?
	try {
		char attrName[100];
		Tango::AutoTangoMonitor synch(this);
	
		if (this->enableLastValueEvents) {
			// Send all CXX_LastValue scalar change events
			for (size_t channel=0; channel < this->numOfChannels; ++channel) {
				try {
					sprintf(attrName, "C%02d_LastValue", channel);
					Tango::WAttribute& attr = this->get_device_attr()->get_w_attr_by_name(attrName);
					this->read_ScalarValue (attr, channel);
					attr.fire_change_event();
				} catch (...) {
					ERROR_STREAM	<< _CFN_ 
									<< " cannot fire last value of channel "
									<< channel << "." << std::endl;
				}
			}
	
			// Send also LastValues spectrum change event
			try {
				Tango::Attribute& attr = this->get_device_attr()->get_attr_by_name(attrName);
				this->read_LastValues(attr);
				attr.fire_change_event();
			} catch (...) {
				ERROR_STREAM	<< _CFN_ 
								<< " cannot fire last channel values change."
								<< std::endl;
			}
		}
	
		if (this->enableChannelValueEvents) {
			// Send all CXX_ChannelValues
			for (size_t channel=0; channel < this->numOfChannels; ++channel) {
				try {
					sprintf(attrName, "C%02d_ChannelValues", channel);
					Tango::Attribute& attr = this->get_device_attr()->get_attr_by_name(attrName);
					this->read_ChannelSpectrum (attr, channel);
					attr.fire_change_event();
				} catch (...) {
					ERROR_STREAM	<< _CFN_ 
									<< " cannot fire event in read channel "
									<< channel << "." << std::endl;
				}
			}
		}

#define __AFSE(attr_name, stat_enabled, stats_op, read_fn) \
		if (m_statsSettings. stat_enabled ) { \
			for (size_t channel=0; channel < this->numOfChannels; ++channel) { \
				try { \
					sprintf(attrName, attr_name, channel);\
					Tango::Attribute& attr = this->get_device_attr()->get_attr_by_name(attrName); \
					\
					this-> read_fn (attr, Stats::stats_op, channel); \
					attr.fire_change_event(); \
				} catch (...) { \
					ERROR_STREAM	<< _CFN_ \
									<< " cannot fire event for " << attrName \
									<< "." << std::endl; \
				} \
			} \
		} else (void)0

#define __ADIODS_FIRE_STATS_EVENT(BigName, small_name) \
		__AFSE("C%02d_" #BigName "Last", event_last_##small_name##_enabled, Operation##BigName, read_ScalarStatistic);\
		__AFSE("C%02d_" #BigName "Values", event_buf_##small_name##_enabled, Operation##BigName, read_SpectrumStatistic);

		__ADIODS_FIRE_STATS_EVENT(Mean, mean);
		__ADIODS_FIRE_STATS_EVENT(StdDev, std_dev);
		__ADIODS_FIRE_STATS_EVENT(QuadraticMean, quadratic_mean);

#undef __ADIODS_FIRE_STATS_EVENT
#undef __AFSE

	} catch (...) {
		ERROR_STREAM	<< _CFN_ 
						<< " Serious problems trying to send events!\n"
						<< " Probably: Unable to get Tango Monitor.\n"
						<< std::endl;
	}
}

}	//	namespace
