static const char *RcsId     = "$Header:  $";
static const char *TagName   = "$Name:  $";
static const char *HttpServer= "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        AdlinkIOCounterClass.cpp
//
// description : C++ source for the AdlinkIOCounterClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the AdlinkIOCounter once per process.
//
// project :     TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Log:  $
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


#include <tango.h>

#include <AdlinkIOCounter.h>
#include <AdlinkIOCounterClass.h>


//+----------------------------------------------------------------------------
/**
 *	Create AdlinkIOCounterClass singleton and return it in a C function for Python usage
 */
//+----------------------------------------------------------------------------
extern "C" {
#ifdef WIN32

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_AdlinkIOCounter_class(const char *name) {
		return AdlinkIOCounter_ns::AdlinkIOCounterClass::init(name);
	}
}


namespace AdlinkIOCounter_ns
{

//+----------------------------------------------------------------------------
//
// method : 		ResetClass::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ResetClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ResetClass::execute(): arrived" << endl;

	((static_cast<AdlinkIOCounter *>(device))->reset());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StartClass::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartClass::execute(): arrived" << endl;

	((static_cast<AdlinkIOCounter *>(device))->start());
	return new CORBA::Any();
}


//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
AdlinkIOCounterClass *AdlinkIOCounterClass::_instance = NULL;

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::AdlinkIOCounterClass(string &s)
// 
// description : 	constructor for the AdlinkIOCounterClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
AdlinkIOCounterClass::AdlinkIOCounterClass(string &s):DeviceClass(s)
{

	cout2 << "Entering AdlinkIOCounterClass constructor" << endl;
	set_default_property();
	get_class_property();
	write_class_property();
	
	cout2 << "Leaving AdlinkIOCounterClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::~AdlinkIOCounterClass()
// 
// description : 	destructor for the AdlinkIOCounterClass
//
//-----------------------------------------------------------------------------
AdlinkIOCounterClass::~AdlinkIOCounterClass()
{
	_instance = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::instance
// 
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
AdlinkIOCounterClass *AdlinkIOCounterClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new AdlinkIOCounterClass(s);
		}
		catch (bad_alloc)
		{
			throw;
		}		
	}		
	return _instance;
}

AdlinkIOCounterClass *AdlinkIOCounterClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::command_factory()
{
	command_list.push_back(new ResetClass("Reset",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StartClass("Start",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
	}
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::get_class_property
// 
// description : 	Get the class property for specified name.
//
// in :		string	name : The property name
//
//+----------------------------------------------------------------------------
Tango::DbDatum AdlinkIOCounterClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::get_default_device_property()
// 
// description : 	Return the default value for device property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum AdlinkIOCounterClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::get_default_class_property()
// 
// description : 	Return the default value for class property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum AdlinkIOCounterClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::device_factory
// 
// description : 	Create the device object(s) and store them in the 
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{

	//	Create all devices.(Automatic code generation)
	//-------------------------------------------------------------
	for (unsigned long i=0 ; i < devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
						
		// Create devices and add it into the device list
		//----------------------------------------------------
		device_list.push_back(new AdlinkIOCounter(this, (*devlist_ptr)[i]));							 

		// Export device to the outside world
		// Check before if database used.
		//---------------------------------------------
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(device_list.back());
		else
			export_device(device_list.back(), (*devlist_ptr)[i]);
	}
	//	End of Automatic code generation
	//-------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//	Method: AdlinkIOCounterClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	//	Attribute : Value
	ValueAttrib	*value = new ValueAttrib();
	Tango::UserDefaultAttrProp	value_prop;
	value_prop.set_description("Reads the counter value of the general-purpose counter without disturbing the counting process.");
	value->set_default_properties(value_prop);
	att_list.push_back(value);

	//	Attribute : StatusRegister
	StatusRegisterAttrib	*status_register = new StatusRegisterAttrib();
	Tango::UserDefaultAttrProp	status_register_prop;
	status_register_prop.set_description("Returns the latched GPTC status of the specified general-purpose timer/counter from the GPTC status register. The format fo Value is as follows:<ul><li>bit 0: Formerly latched status of enable</li><li> bit 1: Formerly latched status of gate</li><li> bit 2: Formerly latched status of up/down</li><li> bit 3: Formerly latched status of output</li><li> bit 4: Formerly latched status of clk</li><li> bit 5: Formerly latched status of interrupt</li><li> bit 6 ~ 15: not used</li></ul>");
	status_register->set_default_properties(status_register_prop);
	att_list.push_back(status_register);

	//	Attribute : SoftwareControlGate
	SoftwareControlGateAttrib	*software_control_gate = new SoftwareControlGateAttrib();
	Tango::UserDefaultAttrProp	software_control_gate_prop;
	software_control_gate_prop.set_max_value("1");
	software_control_gate_prop.set_min_value("0");
	software_control_gate_prop.set_description("Controls the counter/time by software.\n<br/>Only if software gate is configured in SourceGate.\n<br/>The value for GPTC_IntGATE.\n<br/>(D2K_GCTR_Control)");
	software_control_gate->set_default_properties(software_control_gate_prop);
	att_list.push_back(software_control_gate);

	//	Attribute : SoftwareControlUpDown
	SoftwareControlUpDownAttrib	*software_control_up_down = new SoftwareControlUpDownAttrib();
	Tango::UserDefaultAttrProp	software_control_up_down_prop;
	software_control_up_down_prop.set_max_value("1");
	software_control_up_down_prop.set_min_value("0");
	software_control_up_down_prop.set_description("Controls the counter/time by software.\n<br/>Should be enabled by SourceUpDown.\n<br/>The value for GPTC_IntUpDnCTR\n<br/>(D2K_GCTR_Control)");
	software_control_up_down->set_default_properties(software_control_up_down_prop);
	att_list.push_back(software_control_up_down);

	//	Attribute : Mode
	ModeAttrib	*mode = new ModeAttrib();
	Tango::UserDefaultAttrProp	mode_prop;
	mode_prop.set_max_value("8");
	mode_prop.set_min_value("1");
	mode_prop.set_description("Valid:<ul><li> 1: SimpleGatedEventCNT</li><li> 2: SinglePeriodMSR</li><li> 3: SinglePulseWidthMSR</li><li> 4: SingleGatedPulseGen</li><li> 5: SingleTrigPulseGen</li><li> 6: RetrigSinglePulseGen</li><li> 7: SingleTrigContPulseGen</li><li> 8: ContGatedPulseGen</li></ul>Please refer to the hardware manual for the mode description.");
	mode->set_default_properties(mode_prop);
	mode->set_memorized();
	mode->set_memorized_init(true);
	att_list.push_back(mode);

	//	Attribute : SourceTimeBase
	SourceTimeBaseAttrib	*source_time_base = new SourceTimeBaseAttrib();
	Tango::UserDefaultAttrProp	source_time_base_prop;
	source_time_base_prop.set_max_value("1");
	source_time_base_prop.set_min_value("0");
	source_time_base_prop.set_description("<ul><li>0: Internal Time Base\n</li><li>1: External time base from GPTC0_SRC or GPTC1_SRC pin</li></ul>");
	source_time_base->set_default_properties(source_time_base_prop);
	source_time_base->set_memorized();
	source_time_base->set_memorized_init(false);
	att_list.push_back(source_time_base);

	//	Attribute : SourceGate
	SourceGateAttrib	*source_gate = new SourceGateAttrib();
	Tango::UserDefaultAttrProp	source_gate_prop;
	source_gate_prop.set_max_value("1");
	source_gate_prop.set_min_value("0");
	source_gate_prop.set_description("<ul><li>0: Gate is controlled by software (attribute SoftwareControlGate)\n</li><li>1: Gate is controlled by GPTC0_GATE or GPTC1_SRC pin</li></ul>");
	source_gate->set_default_properties(source_gate_prop);
	source_gate->set_memorized();
	source_gate->set_memorized_init(false);
	att_list.push_back(source_gate);

	//	Attribute : SourceUpDown
	SourceUpDownAttrib	*source_up_down = new SourceUpDownAttrib();
	Tango::UserDefaultAttrProp	source_up_down_prop;
	source_up_down_prop.set_max_value("1");
	source_up_down_prop.set_min_value("0");
	source_up_down_prop.set_description("<ul><li>0: Up/Down is controlled by software (attribute SoftwareControlUpDown)\n</li><li>1: Up/Down is controlled by GPTC0_UPDOWN or GPTC1_UPDOWN pin</li></ul>");
	source_up_down->set_default_properties(source_up_down_prop);
	source_up_down->set_memorized();
	source_up_down->set_memorized_init(false);
	att_list.push_back(source_up_down);

	//	Attribute : PolarityLowGate
	PolarityLowGateAttrib	*polarity_low_gate = new PolarityLowGateAttrib();
	Tango::UserDefaultAttrProp	polarity_low_gate_prop;
	polarity_low_gate_prop.set_description("Gate polarity: If true, it is low active. Else it is High active.");
	polarity_low_gate->set_default_properties(polarity_low_gate_prop);
	polarity_low_gate->set_memorized();
	polarity_low_gate->set_memorized_init(false);
	att_list.push_back(polarity_low_gate);

	//	Attribute : PolarityLowUpDown
	PolarityLowUpDownAttrib	*polarity_low_up_down = new PolarityLowUpDownAttrib();
	Tango::UserDefaultAttrProp	polarity_low_up_down_prop;
	polarity_low_up_down_prop.set_description("UpDown polarity: If true, it is low active. Else it is High active.");
	polarity_low_up_down->set_default_properties(polarity_low_up_down_prop);
	polarity_low_up_down->set_memorized();
	polarity_low_up_down->set_memorized_init(false);
	att_list.push_back(polarity_low_up_down);

	//	Attribute : PolarityLowClockEn
	PolarityLowClockEnAttrib	*polarity_low_clock_en = new PolarityLowClockEnAttrib();
	Tango::UserDefaultAttrProp	polarity_low_clock_en_prop;
	polarity_low_clock_en_prop.set_description("ClockEn polarity: If true, it is low active. Else it is High active.");
	polarity_low_clock_en->set_default_properties(polarity_low_clock_en_prop);
	polarity_low_clock_en->set_memorized();
	polarity_low_clock_en->set_memorized_init(false);
	att_list.push_back(polarity_low_clock_en);

	//	Attribute : PolarityLowOutput
	PolarityLowOutputAttrib	*polarity_low_output = new PolarityLowOutputAttrib();
	Tango::UserDefaultAttrProp	polarity_low_output_prop;
	polarity_low_output_prop.set_description("Output polarity: If true, it is low active. Else it is High active.");
	polarity_low_output->set_default_properties(polarity_low_output_prop);
	polarity_low_output->set_memorized();
	polarity_low_output->set_memorized_init(false);
	att_list.push_back(polarity_low_output);

	//	Attribute : InitialCount
	InitialCountAttrib	*initial_count = new InitialCountAttrib();
	Tango::UserDefaultAttrProp	initial_count_prop;
	initial_count_prop.set_description("Initial count of the GPTC.<br/>\nIt is only valid for modes 1 to 3.<br/>\nIn other mdoes it is ignored.\n");
	initial_count->set_default_properties(initial_count_prop);
	initial_count->set_memorized();
	initial_count->set_memorized_init(false);
	att_list.push_back(initial_count);

	//	Attribute : PulseDelay
	PulseDelayAttrib	*pulse_delay = new PulseDelayAttrib();
	Tango::UserDefaultAttrProp	pulse_delay_prop;
	pulse_delay_prop.set_description("Generated pulse delay.<br/>\nOnly for modes 4 to 8, ignored in the rest.");
	pulse_delay->set_default_properties(pulse_delay_prop);
	pulse_delay->set_memorized();
	pulse_delay->set_memorized_init(false);
	att_list.push_back(pulse_delay);

	//	Attribute : PulseWidth
	PulseWidthAttrib	*pulse_width = new PulseWidthAttrib();
	Tango::UserDefaultAttrProp	pulse_width_prop;
	pulse_width_prop.set_description("Generated pulse width.<br/>\nOnly for modes 4 to 8, ignored in the rest.");
	pulse_width->set_default_properties(pulse_width_prop);
	pulse_width->set_memorized();
	pulse_width->set_memorized_init(false);
	att_list.push_back(pulse_width);

	//	End of Automatic code generation
	//-------------------------------------------------------------
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::get_class_property()
// 
// description : 	Read the class properties from database.
//
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::get_class_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read class properties from database.(Automatic code generation)
	//------------------------------------------------------------------

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;


	//	End of Automatic code generation
	//------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 	AdlinkIOCounterClass::set_default_property
// 
// description: Set default property (class and device) for wizard.
//              For each property, add to wizard property name and description
//              If default value has been set, add it to wizard property and
//              store it in a DbDatum.
//
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;

	vector<string>	vect_data;
	//	Set Default Class Properties
	//	Set Default Device Properties
	prop_name = "BoardType";
	prop_desc = "Product descriptor that allow us to identify the card type. Supported values are: DAQ_2205, DAQ_2502, DAQ_2005, DAQ_2010.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "BoardID";
	prop_desc = "It must be an unique identifier for each card on the PC/Rack where it is installed. It is the Board Number in the Rack. So if there are two cards of the same BoardType in the rack, the first will have BoardId=0 and the other BoardId=1.";
	prop_def  = "";
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "CounterID";
	prop_desc = "It's 0 or 1";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkIOCounterClass::write_class_property
// 
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void AdlinkIOCounterClass::write_class_property()
{
	//	First time, check if database used
	//--------------------------------------------
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Counter class for AdlinkIODS devices");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("Some AdlinkIODS analog Input/Output devices also have counter support.");
	str_desc.push_back("This class is to access this functionality.");
	str_desc.push_back("One instance is required for each counter in the board.");
	description << str_desc;
	data.push_back(description);
		
	//	put cvs location
	string	rcsId(RcsId);
	string	filename(classname);
	start = rcsId.find("/");
	if (start!=string::npos)
	{
		filename += "Class.cpp";
		end   = rcsId.find(filename);
		if (end>start)
		{
			string	strloc = rcsId.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	//	Get CVS tag revision
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("Device_4Impl");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	//--------------------------------------------
	get_db_class()->put_property(data);
}

}	// namespace
