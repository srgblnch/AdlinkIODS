static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         AdlinkDIO.cpp
//
// description :  C++ source for the AdlinkDIO and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                AdlinkDIO are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: rsune $
//
// $Revision: 5474 $
//
// $Log$
// Revision 1.2  2007/08/14 06:30:58  rsune
// Get rid of debug messages
//
// Revision 1.1  2007/08/09 11:03:35  rsune
// Initial import: Device for digital input ports for Adlink acquisition boards
//
//
// copyleft :   CELLS/ALBA
//		Edifici Ciences Nord
//		Campus Universitari de Bellaterra
//		Universitat Autonoma de Barcelona
//		08193 Bellaterra, Barcelona, SPAIN
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//=============================================================================



//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//
//===================================================================


#include <tango.h>
#include <AdlinkDIO.h>
#include <AdlinkDIOClass.h>
#include <AdlHelp.h>
#include <AdlDeviceFactorySingleton.h>
#include "AdlinkCommon.h"
#include "tango_utils.h"


namespace AdlinkDIO_ns
{

// This is for devices where m_realPort0isDIandDO == true
static const int __SAME_REAL_IOPORT_DI = 200;
static const int __SAME_REAL_IOPORT_DO = 201;

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::AdlinkDIO(string &s)
// 
// description : 	constructor for simulated AdlinkDIO
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
AdlinkDIO::AdlinkDIO(Tango::DeviceClass *cl,string &s)
:DIO_ns::DIO(cl,s.c_str())
{
	init_device();
}

AdlinkDIO::AdlinkDIO(Tango::DeviceClass *cl,const char *s)
:DIO_ns::DIO(cl,s)
{
	init_device();
}

AdlinkDIO::AdlinkDIO(Tango::DeviceClass *cl,const char *s,const char *d)
:DIO_ns::DIO(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::delete_device()
{
	//	Delete device's allocated object

	DIO::delete_device();

	if(this->m_card > -1)
		AdlDeviceFactorySingleton::release(&this->m_device, AdlDeviceFactorySingleton_::ModeDigital );
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::init_device()
{
	INFO_STREAM << "AdlinkDIO::AdlinkDIO() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	this->m_card = -1;
	this->m_device = 0;

	this->m_isD2k = false;
	this->m_realPort0isDIandDO = false;

	try {

		get_device_property();
	
		std::stringstream bID(this->boardID);
		this->m_cardNumber = 0;
		bID >> m_cardNumber;

		std::string errDesc = 
					"This device should be easily adaptable to manage"
					" a large part of Adlink Analog Acquisition boards"
					" but currently it's only been tested with DAQ_2010"
					" and PCI_9116";
		
		this->m_boardParams = AdlDeviceFactorySingleton::get_board_params(this->boardType);
		if( (!this->m_boardParams) )
			Tango::Except::throw_exception(
					"Unsupported board type", errDesc, __PRETTY_FUNCTION__ );

		if ( (this->m_boardParams->type == DAQ_2010 ) || (this->m_boardParams->type == DAQ_2005 ) || (this->m_boardParams->type == DAQ_2502 ) || (this->m_boardParams->type == DAQ_2205 )) {
			this->m_isD2k = true;
		} else if (this->m_boardParams->type == PCI_9116 ) {
			this->m_realPort0isDIandDO = true;
		} else
			Tango::Except::throw_exception(
					"*Unsupported board type", errDesc, __PRETTY_FUNCTION__ );

		AdlDeviceFactorySingleton::get(
						&this->m_device,
						this->m_boardParams->typeName,
						this->m_cardNumber,
						AdlDeviceFactorySingleton_::ModeDigital );
		this->m_card = this->m_device ? this->m_device->handler() : -1;
		if (this->m_card < 0)
			throw_adlink_error("init_device", "RegisterCard", this->m_card);

		if (this->is_d2k()) {
			this->define_port("P1A", Channel_P1A, 8);
			this->define_port("P1B", Channel_P1B, 8);
			this->define_port("P1C", Channel_P1C, 8);
			this->m_lastValue[Channel_P1A] = 0;
			this->m_lastValue[Channel_P1B] = 0;
			this->m_lastValue[Channel_P1C] = 0;
		
			// These two are not compatible with P1C
			this->define_port("P1CH", Channel_P1CH, 4);
			this->define_port("P1CL", Channel_P1CL, 4);
			this->m_lastValue[Channel_P1CH] = 0;
			this->m_lastValue[Channel_P1CL] = 0;
		} else {
			assert(this->m_realPort0isDIandDO);
			this->define_port("DI", __SAME_REAL_IOPORT_DI, 8);
			this->define_port("DO", __SAME_REAL_IOPORT_DO, 8);
			this->m_lastValue[__SAME_REAL_IOPORT_DI] = 0;
			this->m_lastValue[__SAME_REAL_IOPORT_DO] = 0;
		}

		/// Attribute alias creation will be done by...
		this->set_attribute_factory(&this->m_portFactory);
	
		DIO::init_device(
				this->portAliases,
				this->inputPorts,
				this->outputPorts,
				this->defaultOutput);
		this->set_state(Tango::ON);
	} catch (Tango::DevFailed &e) {
		std::stringstream ss;
		ss << "AdlinkDIO::init_device: Unexpected tango exception.\n";
		ss << e << std::endl;
		std::cerr << "~-~-~-~-~-~-~-~-~-~-~-~" << std::endl << e;
		this->set_state(Tango::UNKNOWN);
		this->set_status(ss.str());
	} catch (std::exception &e) {
		std::cerr	<< "AdlinkDIO::init_device: exception: !!"
					<< e.what() << std::endl;
		this->set_state(Tango::UNKNOWN);
		this->set_status(e.what());
	} catch (...) {
		std::cerr	<< "AdlinkDIO::init_device: Unexpected exception!!"
					<< std::endl;
		this->set_state(Tango::UNKNOWN);
		this->set_status("Unexpected exception");
	}
}


//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("BoardID"));
	dev_prop.push_back(Tango::DbDatum("BoardType"));
	dev_prop.push_back(Tango::DbDatum("InputPorts"));
	dev_prop.push_back(Tango::DbDatum("OutputPorts"));
	dev_prop.push_back(Tango::DbDatum("PortAliases"));
	dev_prop.push_back(Tango::DbDatum("DefaultOutput"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	AdlinkDIOClass	*ds_class =
		(static_cast<AdlinkDIOClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize BoardID from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  boardID;
	//	Try to initialize BoardID from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  boardID;
	//	And try to extract BoardID value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  boardID;

	//	Try to initialize BoardType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  boardType;
	//	Try to initialize BoardType from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  boardType;
	//	And try to extract BoardType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  boardType;

	//	Try to initialize InputPorts from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  inputPorts;
	//	Try to initialize InputPorts from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  inputPorts;
	//	And try to extract InputPorts value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  inputPorts;

	//	Try to initialize OutputPorts from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  outputPorts;
	//	Try to initialize OutputPorts from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  outputPorts;
	//	And try to extract OutputPorts value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  outputPorts;

	//	Try to initialize PortAliases from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  portAliases;
	//	Try to initialize PortAliases from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  portAliases;
	//	And try to extract PortAliases value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  portAliases;

	//	Try to initialize DefaultOutput from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  defaultOutput;
	//	Try to initialize DefaultOutput from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  defaultOutput;
	//	And try to extract DefaultOutput value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  defaultOutput;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void AdlinkDIO::always_executed_hook()
{
	
}
//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "AdlinkDIO::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::read_BoardPorts
// 
// description : 	Extract real attribute values for BoardPorts acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::read_BoardPorts(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::read_BoardPorts(Tango::Attribute &attr) entering... "<< endl;

	const std::vector<Tango::DevString> & table = this->read_board_ports();

	attr.set_value(const_cast<char**>(&table[0]), table.size());
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::read_PortTemplateBOOLEAN
// 
// description : 	Extract real attribute values for PortTemplateBOOLEAN acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::read_PortTemplateBOOLEAN(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::read_PortTemplateBOOLEAN(Tango::Attribute &attr) entering... "<< endl;

	this->read_port_attribute<Tango::DevBoolean>(attr);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::write_PortTemplateBOOLEAN
// 
// description : 	Write PortTemplateBOOLEAN attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::write_PortTemplateBOOLEAN(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::write_PortTemplateBOOLEAN(Tango::WAttribute &attr) entering... "<< endl;

	this->write_port_attribute<Tango::DevBoolean>(attr);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::read_PortTemplateUSHORT
// 
// description : 	Extract real attribute values for PortTemplateUSHORT acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::read_PortTemplateUSHORT(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::read_PortTemplateUSHORT(Tango::Attribute &attr) entering... "<< endl;

	this->read_port_attribute<Tango::DevUShort>(attr);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::write_PortTemplateUSHORT
// 
// description : 	Write PortTemplateUSHORT attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::write_PortTemplateUSHORT(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::write_PortTemplateUSHORT(Tango::WAttribute &attr) entering... "<< endl;

	this->write_port_attribute<Tango::DevUShort>(attr);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::read_PortTemplateLONG
// 
// description : 	Extract real attribute values for PortTemplateLONG acquisition result.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::read_PortTemplateLONG(Tango::Attribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::read_PortTemplateLONG(Tango::Attribute &attr) entering... "<< endl;

	this->read_port_attribute<Tango::DevLong>(attr);
}

//+----------------------------------------------------------------------------
//
// method : 		AdlinkDIO::write_PortTemplateLONG
// 
// description : 	Write PortTemplateLONG attribute values to hardware.
//
//-----------------------------------------------------------------------------
void AdlinkDIO::write_PortTemplateLONG(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "AdlinkDIO::write_PortTemplateLONG(Tango::WAttribute &attr) entering... "<< endl;

	this->write_port_attribute<Tango::DevLong>(attr);
}



/*virtual*/ bool AdlinkDIO::configure_ports(
		const StringSet& inputs,
		const StringSet& outputs)
{

	if (!this->is_d2k()) {
		assert(this->m_realPort0isDIandDO);
		if ( inputs.count("DO") || outputs.count("DI") )
			return false;
		return true;
	}

	/// Check ports compatability (part of it has already
	/// been done by the abstract)
	/// In this case, P1CH/P1CL is not compatible with P1C
	if ( inputs.count("P1C") || outputs.count("P1C") ) {
		if  ( inputs.count("P1CH") || outputs.count("P1CH") || inputs.count("P1CL") || outputs.count("P1CL") )
			Tango::Except::throw_exception(
					"Incompatible ports",
					"If you use P1CH or P1CL on your input/output port selection,"
					" you can\'t select the whole P1C too.",
					"AdlinkDIO::configure_port");
	}

	/// Set-up the hardware according to the configuration
	StringSet::const_iterator i, e;

	i = inputs.begin();
	e = inputs.end();
	for(; i != e; ++i) {
		unsigned int id = this->get_port_id(*i);
		std::cout << "porin: \"" << *i << "\" " << id << std::endl;
		this->m_isOutputPort[id] = false;
		//this->m_lastValue[id] = 0;
		D2K_DIO_PortConfig(this->m_card, id, INPUT_PORT);
	}
	
	i = outputs.begin();
	e = outputs.end();
	for(; i != e; ++i) {
		unsigned int id = this->get_port_id(*i);
		std::cout << "porout: \"" << *i << "\" " << id << std::endl;
		this->m_isOutputPort[id] = true;
		//this->m_lastValue[id] = 0;
		D2K_DIO_PortConfig(this->m_card, id, OUTPUT_PORT);
	}
	return true;
}


/*virtual*/ unsigned int AdlinkDIO::read_port(unsigned int portID)
{
	U32 val;
	
	if (!this->m_isOutputPort[portID]) {
		if (this->is_d2k())
			assert_adlink(
				D2K_DI_ReadPort(this->m_card, portID, &val),
				"DI_ReadPort" );
		else {
			assert(this->m_realPort0isDIandDO);
			assert_adlink(
				DI_ReadPort(this->m_card, 0, &val),
				"DI_ReadPort" );
		}
	} else // Output port, we can't read it
		val = this->m_lastValue[portID]; //So, we use the last written

	return val;
}

/*virtual*/ void AdlinkDIO::write_port(unsigned int portID, unsigned int value,
				     unsigned int mask)
{
	if(this->m_isOutputPort[portID]) { //Output 32 bit port
		unsigned int v = this->m_lastValue[portID];
		v &= ~mask;
		v |= value;
		if (this->is_d2k()) {
			assert_adlink(
				D2K_DO_WritePort(this->m_card, portID, v),
				"DO_WritePort" );
		} else {
			assert(this->m_realPort0isDIandDO);
			assert_adlink(
				DO_WritePort(this->m_card, 0, v),
				"DO_WritePort" );
		}
		this->m_lastValue[portID] = v;
	}else
		throw "//TODO: ERROR";
}

/*virtual*/ void AdlinkDIO::write_port_initial_output_value(
				unsigned int portID,
				unsigned int value,
				unsigned int mask)
{
	unsigned int v = this->m_lastValue[portID];
	v &= ~mask;
	v |= value;

	if (this->is_d2k()) {
		assert_adlink(
			D2K_DO_WritePort(this->m_card, portID, v),
			"DO_WritePort" );
	} else {
		assert_adlink(
			DO_WritePort(this->m_card, 0, v),
			"DO_WritePort" );
	}
	this->m_lastValue[portID] = v;
}

}	//	namespace


/*static*/ DevicePartInterface* AdlDeviceFactorySingleton::create_digital_device(CommonDeviceInterface* commonDevice)
{
	return new DigitalIODeviceInterface( commonDevice );
}
